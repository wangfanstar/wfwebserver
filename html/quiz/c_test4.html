
<!DOCTYPE html>  
<html lang="zh-CN">  
<head>  
    <meta charset="UTF-8">  
    <meta name="viewport" content="width=device-width, initial-scale=1.0">  
    <title>C语言测验 - 数据结构与算法优化</title>  
    <!-- 本地样式和脚本文件 -->  
    <link href="../tailwind.min.css" rel="stylesheet">  
    <script src="../alpine.min.js" defer></script>  
    <style>  
        .question {  
            border-bottom: 1px solid #e2e8f0;  
            padding-bottom: 1.5rem;  
            margin-bottom: 1.5rem;  
        }  
        .correct {  
            color: #059669;  
            font-weight: bold;  
        }  
        .incorrect {  
            color: #dc2626;  
            font-weight: bold;  
        }  
        .explanation {  
            background-color: #f8fafc;  
            border-left: 4px solid #3b82f6;  
            padding: 1rem;  
            margin-top: 1rem;  
        }  
        .sidebar {  
            position: sticky;  
            top: 20px;  
            height: calc(100vh - 40px);  
            overflow-y: auto;  
        }  
        @media print {  
            .no-print {  
                display: none;  
            }  
            .print-break {  
                page-break-before: always;  
            }  
        }  
    </style>  
</head>  
<body class="bg-gray-50">  
    <div x-data="quizApp()" class="container mx-auto px-4 py-8">  
        <header class="text-center mb-10">  
            <div class="mx-auto w-24 h-24 mb-4">  
                <svg viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">  
                    <path d="M70 20H30C24.4772 20 20 24.4772 20 30V70C20 75.5228 24.4772 80 30 80H70C75.5228 80 80 75.5228 80 70V30C80 24.4772 75.5228 20 70 20Z" fill="#3B82F6"/>  
                    <path d="M50 25C36.1929 25 25 36.1929 25 50C25 63.8071 36.1929 75 50 75C63.8071 75 75 63.8071 75 50C75 36.1929 63.8071 25 50 25Z" fill="white"/>  
                    <path d="M50 30C38.9543 30 30 40.9543 30 55C30 69.0457 38.9543 80 50 80C61.0457 80 70 69.0457 70 55C70 40.9543 61.0457 30 50 30Z" fill="#3B82F6"/>  
                    <text x="50" y="60" font-family="Arial" font-size="24" font-weight="bold" fill="white" text-anchor="middle">C</text>  
                    <path d="M75 30H80L85 35V40H80V35H75V30Z" fill="#FFA55F"/>  
                    <path d="M25 70H20L15 65V60H20V65H25V70Z" fill="#FFA55F"/>  
                </svg>  
            </div>  
            <h1 class="text-3xl font-bold text-gray-800">C语言编程测验之数据结构和算法优化100</h1>  
            <p class="text-gray-600 mt-2">共100道选择题，答题后点击"检查答案"查看结果和解析</p>  
        </header>  

        <div class="flex flex-col md:flex-row gap-8">  
            <!-- 左侧边栏：固定进度和统计信息 -->  
            <div class="w-full md:w-1/4 lg:w-1/5 no-print">  
                <div class="sidebar bg-white rounded-lg shadow-md p-4">  
                    <h2 class="text-lg font-medium text-gray-900 mb-4">测验进度</h2>  
                    
                    <div class="progress-bar mb-6">  
                        <div class="flex justify-between mb-1">  
                            <span class="text-sm font-medium text-blue-700">完成题目</span>  
                            <span class="text-sm font-medium text-blue-700" x-text="answeredCount + ' / ' + questions.length"></span>  
                        </div>  
                        <div class="w-full bg-gray-200 rounded-full h-2.5">  
                            <div class="bg-blue-600 h-2.5 rounded-full" :style="'width: ' + (answeredCount / questions.length * 100) + '%'"></div>  
                        </div>  
                    </div>  
                    
                    <div class="stats space-y-4 mb-8">  
                        <div class="stat bg-gray-50 rounded-lg p-3">  
                            <div class="text-sm text-gray-600">正确答案</div>  
                            <div class="text-2xl font-bold text-green-600" x-text="correctCount"></div>  
                        </div>  
                        <div class="stat bg-gray-50 rounded-lg p-3">  
                            <div class="text-sm text-gray-600">错误答案</div>  
                            <div class="text-2xl font-bold text-red-600" x-text="incorrectCount"></div>  
                        </div>  
                        <div class="stat bg-gray-50 rounded-lg p-3">  
                            <div class="text-sm text-gray-600">准确率</div>  
                            <div class="text-2xl font-bold text-blue-600" x-text="accuracyRate + '%'"></div>  
                        </div>  
                    </div>  
                    
                    <div class="jump-to-section">  
                        <h3 class="text-md font-medium text-gray-900 mb-2">快速跳转</h3>  
                        <div class="grid grid-cols-5 gap-1">  
                            <template x-for="i in 20">  
                                <button class="py-1 text-xs rounded hover:bg-blue-100"   
                                        :class="getJumpButtonClass((i-1)*5+1)"  
                                        @click="scrollToQuestion((i-1)*5+1)">  
                                    <span x-text="(i-1)*5+1"></span>-<span x-text="i*5"></span>  
                                </button>  
                            </template>  
                        </div>  
                    </div>  
                    
                    <div class="mt-8">  
                        <button @click="printResults()" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded">  
                            打印测验结果  
                        </button>  
                    </div>  
                </div>  
            </div>  
            
            <!-- 右侧主要内容：题目列表 -->  
            <div class="w-full md:w-3/4 lg:w-4/5">  
                <div class="bg-white rounded-lg shadow-md p-6">  
                    <template x-for="(question, index) in questions" :key="index">  
                        <div class="question" :id="'question-' + (index + 1)" :class="{'print-break': index > 0 && index % 5 === 0}">  
                            <h3 class="text-lg font-medium text-gray-900 mb-2">  
                                <span x-text="(index + 1) + '.'"></span>  
                                <span x-html="question.text"></span>  
                            </h3>  
                            <div class="options grid grid-cols-1 md:grid-cols-2 gap-2 mb-4">  
                                <template x-for="(option, optIndex) in ['A', 'B', 'C', 'D']" :key="optIndex">  
                                    <div class="flex items-start">  
                                        <input type="radio" :id="'q' + (index + 1) + option" :name="'question' + (index + 1)" :value="option"   
                                               x-model="question.userAnswer"   
                                               class="mt-1 mr-2">  
                                        <label :for="'q' + (index + 1) + option" class="text-gray-700" x-html="question.options[optIndex]"></label>  
                                    </div>  
                                </template>  
                            </div>  
                            <div class="flex items-center">  
                                <button @click="checkAnswer(index)"   
                                        class="bg-blue-600 hover:bg-blue-700 text-white font-medium py-1 px-4 rounded no-print"  
                                        :disabled="question.checked"  
                                        :class="{'opacity-50 cursor-not-allowed': question.checked}">  
                                    检查答案  
                                </button>  
                                <div x-show="question.checked" class="ml-4" :class="question.userAnswer === question.correctAnswer ? 'correct' : 'incorrect'">  
                                    <span x-show="question.userAnswer === question.correctAnswer">✓ 正确答案！</span>  
                                    <span x-show="question.userAnswer !== question.correctAnswer">✗ 错误。正确答案是: <span x-text="question.correctAnswer"></span></span>  
                                </div>  
                            </div>  
                            <div x-show="question.checked && question.explanation" class="explanation mt-2" x-html="question.explanation"></div>  
                        </div>  
                    </template>  
                </div>  
            </div>  
        </div>  
    </div>  

    <!-- 这里是关键修改：使用script标签定义问题数据 -->
    <script id="questionData" type="text/plain">
    {  
        text: '单链表的节点通常由哪两部分组成？',  
        options: ['数据域和计数器', '数据域和指针域', '前驱指针和后继指针', '数据域和权重'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '单链表的节点通常由数据域和指针域两部分组成。数据域用于存储节点的值，指针域用于存储指向下一个节点的指针。'  
    },  
    {  
        text: '在含有n个节点的单链表中，删除第i个节点的时间复杂度是多少？',  
        options: ['O(1)', 'O(i)', 'O(n)', 'O(n-i)'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '在单链表中删除第i个节点，需要先遍历到第i-1个节点，这需要O(i)的时间，然后进行删除操作需要O(1)的时间，因此总时间复杂度为O(i)。'  
    },  
    {  
        text: '以下哪种数据结构可以高效地在任意位置进行插入和删除操作？',  
        options: ['数组', '队列', '栈', '双向链表'],  
        correctAnswer: 'D',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '双向链表由于每个节点同时包含前驱和后继指针，可以高效地在任意位置进行插入和删除操作，时间复杂度为O(1)（假设已知位置）。而数组、队列和栈在某些位置的插入删除操作需要移动大量元素。'  
    },  
    {  
        text: '判断单链表是否有环的最优算法是什么？',  
        options: ['使用哈希表记录已访问节点', '使用栈存储已访问节点', '每次遍历比较所有已访问节点', '快慢指针法（Floyd环检测算法）'],  
        correctAnswer: 'D',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '快慢指针法（Floyd环检测算法）是检测链表环的最优算法，空间复杂度为O(1)。该方法设置两个指针，一个每次移动一步，另一个每次移动两步，如果存在环，两个指针最终会相遇。'  
    },  
    {  
        text: '单链表的反转操作是指什么？',  
        options: ['对链表节点的值进行排序', '将链表中的节点顺序颠倒', '交换链表中每对相邻节点', '将链表转换为双向链表'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '单链表的反转操作是指将链表中的节点顺序颠倒，使原来的头节点变成尾节点，原来的尾节点变成头节点，以此类推。这通常通过改变节点的指针指向来实现。'  
    },  
    {  
        text: '循环链表与普通链表的主要区别是什么？',  
        options: ['循环链表没有头节点', '循环链表的节点有多个后继', '循环链表的最后一个节点指向第一个节点而不是NULL', '循环链表只能从尾部访问'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '循环链表的主要特点是其最后一个节点的指针不是NULL，而是指向链表的第一个节点，形成一个环。这使得可以从任何节点开始遍历整个链表。'  
    },  
    {  
        text: '队列的特点是什么？',  
        options: ['先进后出(FILO)', '后进先出(LIFO)', '先进先出(FIFO)', '随机访问'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '队列是一种先进先出(FIFO)的数据结构，元素只能从队尾插入，从队首删除。先放入队列的元素会先被取出。'  
    },  
    {  
        text: '使用数组实现队列时，处理"假溢出"常用的方法是什么？',  
        options: ['动态扩容', '循环队列', '链式队列', '栈实现'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '数组实现队列时，随着元素的入队和出队，队头指针会不断后移，可能导致队列前部有空闲空间但队尾指针已到达数组末尾的"假溢出"现象。循环队列通过将数组首尾相连，使队头和队尾指针在数组中循环移动，有效解决了这个问题。'  
    },  
    {  
        text: '以下哪种情况下，链式队列比顺序队列更具优势？',  
        options: ['需要随机访问队列元素时', '队列大小需要频繁变化时', '内存资源非常有限时', '需要快速判断队列是否为空时'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '当队列大小需要频繁变化时，链式队列更具优势，因为它不需要预先分配固定大小的内存，可以根据需要动态分配和释放节点。而顺序队列需要预先分配固定大小的数组，如果需要扩容，可能需要创建新数组并复制所有元素。'  
    },  
    {  
        text: '生产者-消费者模型中，队列的主要作用是什么？',  
        options: ['计算资源占用', '协调生产者和消费者的速度差异', '管理线程优先级', '负载均衡'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '在生产者-消费者模型中，队列作为缓冲区，主要用于协调生产者和消费者之间的速度差异。生产者将生产的数据放入队列，消费者从队列中取出数据进行处理，使得两者可以异步工作，提高系统效率。'  
    },  
    {  
        text: '栈的基本特点是什么？',  
        options: ['先进先出(FIFO)', '随机存取', '先进后出(LIFO)', '循环访问'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '栈是一种先进后出(LIFO)的数据结构，元素只能在一端（栈顶）进行插入和删除操作。最后放入栈的元素会最先被取出。'  
    },  
    {  
        text: '以下哪个应用场景最适合使用栈数据结构？',  
        options: ['任务调度', '表达式求值', '广度优先搜索', '图的最短路径'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '表达式求值是栈的典型应用场景。通过使用栈可以方便地处理操作符的优先级和括号匹配，实现中缀表达式转后缀表达式以及后缀表达式的计算。'  
    },  
    {  
        text: '使用栈实现递归的好处是什么？',  
        options: ['减少内存使用', '提高程序的可读性', '避免函数调用开销', '防止递归深度过大导致的栈溢出'],  
        correctAnswer: 'D',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '使用栈手动实现递归（即转换为迭代）的主要好处是可以控制栈的大小，防止递归深度过大导致的栈溢出问题。程序可以根据需要动态调整栈的大小，或者实现更高效的栈管理策略。'  
    },  
    {  
        text: '栈的"下溢"是指什么情况？',  
        options: ['栈满时继续入栈', '栈空时尝试出栈', '入栈元素太多导致内存不足', '出栈操作太慢'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '栈的"下溢"是指当栈为空时还尝试执行出栈操作。这是一种异常情况，可能导致程序错误。良好的栈实现应该在出栈前检查栈是否为空。'  
    },  
    {  
        text: '在二叉树中，如果一个节点有左子树，那么左子树上所有节点的值都应该小于该节点的值。这样的二叉树被称为什么？',  
        options: ['平衡二叉树', '完全二叉树', '二叉搜索树', '满二叉树'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '二叉搜索树（BST）的特点是对于任意节点，其左子树上所有节点的值均小于该节点值，右子树上所有节点的值均大于该节点值。这种特性使得二叉搜索树的查找、插入和删除操作非常高效。'  
    },  
    {  
        text: '完全二叉树的定义是什么？',  
        options: ['每个节点都有0或2个子节点的二叉树', '除最后一层外，每一层都被完全填充，且最后一层的所有节点都尽可能地靠左排列', '所有叶子节点都在同一层的二叉树', '任意两个叶子节点的深度差不超过1的二叉树'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '完全二叉树的定义是：除最后一层外，每一层都被完全填充，且最后一层的所有节点都尽可能地靠左排列。这种结构使得完全二叉树可以高效地用数组表示。'  
    },  
    {  
        text: '平衡二叉搜索树（如AVL树）相比普通二叉搜索树的主要优势是什么？',  
        options: ['节省存储空间', '插入操作更简单', '保证查找操作的最坏时间复杂度为O(log n)', '支持更多种类的查询操作'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '平衡二叉搜索树（如AVL树）通过保持树的平衡，确保树的高度始终保持在O(log n)级别，从而保证了查找、插入和删除操作的最坏时间复杂度为O(log n)。而普通二叉搜索树在最坏情况下（如插入已排序的数据）会退化成链表，查找操作的时间复杂度变为O(n)。'  
    },  
    {  
        text: '二叉树的前序遍历是指按照什么顺序访问节点？',  
        options: ['根节点→左子树→右子树', '左子树→根节点→右子树', '左子树→右子树→根节点', '根节点→右子树→左子树'],  
        correctAnswer: 'A',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '二叉树的前序遍历（Preorder Traversal）是指按照"根节点→左子树→右子树"的顺序访问树中的节点。即先访问当前节点，然后递归地前序遍历左子树，最后递归地前序遍历右子树。'  
    },  
    {  
        text: '以下哪种数据结构最适合实现树的层序遍历（广度优先遍历）？',  
        options: ['栈', '队列', '链表', '哈希表'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '队列是实现树的层序遍历（广度优先遍历）的最佳数据结构。层序遍历需要按层访问节点，即先访问第一层，再访问第二层，以此类推。使用队列可以保证按照节点进入队列的顺序进行处理，实现逐层遍历。'  
    },  
    {  
        text: '图的邻接矩阵表示法有什么特点？',  
        options: ['节省存储空间，尤其对于稀疏图', '无法表示带权图', '快速判断两个顶点之间是否有边', '不支持有向图的表示'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '图的邻接矩阵表示法使用一个二维数组来表示图中顶点之间的连接关系。其主要特点是可以在O(1)时间内判断两个顶点之间是否有边。但对于稀疏图（边数远小于顶点数的平方），邻接矩阵会浪费大量空间。邻接矩阵可以表示带权图（存储权重而不是布尔值）和有向图。'  
    },  
    {  
        text: '图的邻接表表示法相比邻接矩阵的主要优势是什么？',  
        options: ['更易于实现', '对稀疏图更节省空间', '查询两点间是否有边更快', '更适合完全图'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '图的邻接表表示法对于稀疏图（边数远小于顶点数的平方）更节省空间，因为它只存储实际存在的边。而邻接矩阵无论图中实际有多少边，都需要n²的空间（n为顶点数）。但邻接表在查询两点间是否有边时效率较低，需要遍历链表。'  
    },  
    {  
        text: '深度优先搜索(DFS)和广度优先搜索(BFS)的主要区别是什么？',  
        options: ['DFS使用递归，BFS不使用', 'DFS优先探索深度，BFS优先探索广度', 'DFS只适用于有向图，BFS只适用于无向图', 'DFS的时间复杂度更低'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'DFS和BFS的主要区别在于搜索策略：DFS优先探索深度，即尽可能深地搜索图的分支，通常使用栈（或递归）实现；BFS优先探索广度，即先访问离起始顶点最近的顶点，然后再访问离这些顶点最近的顶点，通常使用队列实现。两种算法都可用于有向图和无向图，且时间复杂度都是O(V+E)，其中V是顶点数，E是边数。'  
    },  
    {  
        text: '在图的应用中，查找最短路径常用的算法是什么？',  
        options: ['深度优先搜索', '广度优先搜索（无权图）或Dijkstra算法（带权图）', '拓扑排序', 'Kruskal算法'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '在无权图中，广度优先搜索(BFS)可以找到从源点到其他所有点的最短路径（以边的数量计）。在带权图中，Dijkstra算法是一种常用的单源最短路径算法，可以找到从一个顶点到图中所有其他顶点的最短路径。Kruskal算法用于求最小生成树，而不是最短路径。'  
    },  
    {  
        text: '顺序查找算法的平均时间复杂度是多少？',  
        options: ['O(1)', 'O(log n)', 'O(n)', 'O(n²)'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '顺序查找（线性查找）算法的平均时间复杂度是O(n)，其中n是待查找数据的规模。在最坏情况下（目标元素在最后或不存在），需要检查所有n个元素。'  
    },  
    {  
        text: '二分查找算法的前提条件是什么？',  
        options: ['数据必须是有序的', '数据量必须是2的幂', '必须使用数组存储数据', '数据必须可以比较大小'],  
        correctAnswer: 'A',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '二分查找的前提条件是数据必须是有序的（升序或降序）。该算法通过比较中间元素与目标值的大小，每次排除一半的搜索范围，从而实现O(log n)的查找时间复杂度。'  
    },  
    {  
        text: '哈希表的主要优势是什么？',  
        options: ['总是保持元素的有序性', '支持高效的范围查询', '提供近乎O(1)的查找、插入和删除操作', '节省存储空间'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '哈希表的主要优势是在理想情况下提供O(1)时间复杂度的查找、插入和删除操作。这是通过哈希函数将键映射到数组索引来实现的。但哈希表不保持元素的有序性，不适合范围查询，且通常需要额外的空间来减少冲突。'  
    },  
    {  
        text: '插入排序的基本思想是什么？',  
        options: ['不断选择最小元素放到已排序部分的末尾', '通过交换相邻元素将最大元素冒泡到末尾', '将待排序元素依次插入到已排序部分的适当位置', '将数据分成小块独立排序后合并'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '插入排序的基本思想是将待排序的元素依次插入到已排序部分的适当位置。算法从第二个元素开始，将其与前面已排序的元素比较，找到合适的位置插入。该过程类似于打牌时整理手中的牌。'  
    },  
    {  
        text: '以下哪种排序算法是不稳定的？',  
        options: ['冒泡排序', '插入排序', '归并排序', '快速排序'],  
        correctAnswer: 'D',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '快速排序是不稳定的排序算法，因为它可能改变相等元素的相对顺序。冒泡排序、插入排序和归并排序都是稳定的排序算法，它们能保证相等元素的相对顺序在排序后不变。'  
    },  
    {  
        text: '归并排序的时间复杂度是多少？',  
        options: ['O(n)', 'O(n log n)', 'O(n²)', 'O(2ⁿ)'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '归并排序的时间复杂度是O(n log n)，这也是基于比较的排序算法能达到的最优时间复杂度。归并排序通过分治策略，将数组分成两半分别排序，然后合并结果，从而实现高效排序。'  
    },  
    {  
        text: '以下哪种排序算法在最好情况下的时间复杂度是O(n)？',  
        options: ['快速排序', '堆排序', '插入排序', '归并排序'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '插入排序在最好情况下（输入数组已经排序）的时间复杂度是O(n)，因为只需要进行n-1次比较而不需要移动元素。而快速排序、堆排序和归并排序即使在最好情况下时间复杂度也是O(n log n)。'  
    },  
    {  
        text: '在时间复杂度的表示中，O(1)表示什么？',  
        options: ['算法的执行时间总是恒定的', '算法的执行时间与输入数据的大小无关', '算法只执行一次操作', '算法的执行时间正比于输入数据的大小'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'O(1)表示常数时间复杂度，意味着算法的执行时间与输入数据的大小无关。无论输入数据多大，算法的执行时间都保持相对恒定。例如，数组的索引访问、栈的压入和弹出操作通常是O(1)的。'  
    },  
    {  
        text: '空间复杂度O(n)表示什么？',  
        options: ['算法需要的额外空间与输入数据大小无关', '算法只需要常数额外空间', '算法需要的额外空间与输入数据大小成正比', '算法需要的额外空间是输入数据大小的平方'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '空间复杂度O(n)表示算法需要的额外空间与输入数据大小n成正比。这意味着随着输入数据量的增加，算法所需的额外空间也线性增加。例如，创建一个与输入大小相同的新数组来存储结果。'  
    },  
    {  
        text: '在以下算法中，哪个具有最高的时间复杂度？',  
        options: ['O(n log n)', 'O(n²)', 'O(2ⁿ)', 'O(n³)'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'O(2ⁿ)表示指数时间复杂度，是这些选项中增长最快的。当n增加时，O(2ⁿ)的增长速度远超过O(n log n)、O(n²)和O(n³)。例如，当n=10时，2ⁿ=1024，而n³=1000。指数时间复杂度的算法通常只适用于处理非常小的输入。'  
    },  
    {  
        text: '以下哪种算法策略适合解决"旅行商问题"（在n个城市间找到最短的巡回路径）？',  
        options: ['分治法', '动态规划（小规模问题）或近似算法（大规模问题）', '贪心算法', '线性规划'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '旅行商问题是一个NP-Hard问题。对于小规模问题，可以使用动态规划获得精确解；而对于大规模问题，通常使用近似算法或启发式算法（如遗传算法、模拟退火）来获得近似解，因为精确求解的时间复杂度是指数级的。贪心算法可能得到次优解，而分治法和线性规划不是解决该问题的常用方法。'  
    },  
    {  
        text: '代码性能优化中，"循环展开"技术的主要目的是什么？',  
        options: ['减少代码量', '提高代码可读性', '减少循环控制开销并利用指令级并行', '节省内存空间'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '循环展开是一种通过增加每次迭代中的操作量来减少循环次数的优化技术。其主要目的是减少循环控制开销（如条件检查和索引递增）并且可以更好地利用指令级并行性，从而提高性能。但这通常会增加代码量并可能降低可读性。'  
    },  
    {  
        text: '以下哪种位操作可以用来检查一个整数是否为2的幂？',  
        options: ['n & (n-1) == 0', 'n | (n-1) == 0', 'n ^ (n-1) == 0', 'n % 2 == 0'],  
        correctAnswer: 'A',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '对于任何2的幂n，表达式n & (n-1) == 0成立。这是因为2的幂在二进制表示中只有一个1（如4是100，8是1000），而n-1会将这个1变成0，并将右边的所有位变为1（如3是011，7是0111）。因此n & (n-1)会清除所有位，结果为0。n % 2 == 0只能检查是否为偶数。'  
    },  
    {  
        text: '以下哪个操作可以用位操作高效实现？',  
        options: ['计算两个非负整数的最大公约数', '判断一个数是否为素数', '计算一个数的两倍', '计算两个浮点数的平均值'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '计算一个整数的两倍可以通过左移一位（n << 1）高效实现，相当于将所有位向左移动一位，在二进制表示中相当于乘以2。位操作通常不适用于处理浮点数或复杂的数学问题如最大公约数计算和素数判断。'  
    },  
    {  
        text: '在算法优化中，"空间换时间"策略的典型应用是什么？',  
        options: ['循环展开', '预计算查表', '尾递归优化', '内联函数'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '预计算查表是"空间换时间"策略的典型应用。它通过预先计算可能的结果并存储在表（通常是数组或哈希表）中，在需要时直接查表获取结果，而不是每次都重新计算。这种方法以增加内存使用为代价，显著减少了运行时间。例如，三角函数表、CRC校验表等。'  
    },  
    {  
        text: '以下哪种数据结构适合实现LRU（最近最少使用）缓存？',  
        options: ['数组', '栈', '队列', '哈希表 + 双向链表'],  
        correctAnswer: 'D',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'LRU缓存需要两个关键操作：快速查找（确定元素是否在缓存中）和快速更新访问顺序（移除最久未使用的元素）。哈希表提供O(1)的查找，而双向链表允许在O(1)时间内从任意位置删除节点并添加到链表头部。这种组合结构能高效实现LRU缓存的所有操作。'  
    },  
    {  
        text: '关于快速排序的轴选择（pivot selection），以下哪种方法可能导致最坏情况下的性能？',  
        options: ['随机选择元素作为轴', '选择第一个元素作为轴', '选择中间元素作为轴', '三数取中法（首、尾、中间三个元素的中值）'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '选择第一个元素作为轴可能导致快速排序在处理已排序或近乎排序的数组时性能最差（时间复杂度退化为O(n²)）。这是因为每次划分都会产生极不平衡的子问题：一个大小为n-1的子问题和一个大小为0的子问题。而随机选择轴、选择中间元素或三数取中法都能在很大程度上避免这种最坏情况。'  
    },  
    {  
        text: '以下哪种数据结构最适合实现字典（关联数组）？',  
        options: ['数组', '链表', '哈希表或平衡搜索树', '栈'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '哈希表或平衡搜索树（如红黑树）最适合实现字典（关联数组）。哈希表提供平均O(1)的查找、插入和删除操作，而平衡搜索树提供最坏情况下O(log n)的性能并保持键的有序性。数组和链表不支持高效的关联查找，栈只支持后进先出的访问模式。'  
    },  
    {  
        text: '编程中的"死锁"是指什么情况？',  
        options: ['程序无限循环', '两个或多个线程互相等待对方持有的资源，导致所有相关线程无法继续执行', '程序崩溃并终止执行', '内存泄漏导致程序无法分配新内存'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '死锁是指两个或多个线程互相等待对方持有的资源，形成一个循环等待的情况，导致所有相关线程都无法继续执行。例如，线程A持有资源1并等待资源2，而线程B持有资源2并等待资源1，两者都无法继续执行。死锁是并发编程中的一个常见问题，可以通过资源分配策略（如资源排序）或死锁检测与恢复机制来防止或解决。'  
    },  
    {  
        text: '红黑树是一种自平衡二叉搜索树，它的一个关键特性是什么？',  
        options: ['所有叶节点都是红色的', '根节点必须是黑色的', '树的高度必须是偶数', '红色节点不能有黑色子节点'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '红黑树的关键特性包括：1) 每个节点是红色或黑色；2) 根节点必须是黑色；3) 所有叶节点（NIL节点）是黑色；4) 如果一个节点是红色，则其子节点必须都是黑色；5) 对于每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点。这些特性共同保证了树的平衡性，使得最长路径不超过最短路径的两倍。'  
    },  
    {  
        text: '动态规划算法与分治算法的主要区别是什么？',  
        options: ['动态规划总是自底向上，分治总是自顶向下', '动态规划解决最优化问题，分治解决查找问题', '动态规划通过存储子问题的解避免重复计算，分治则重新计算子问题', '动态规划只能用于连续数据，分治只能用于离散数据'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '动态规划和分治都是将问题分解为子问题，但主要区别在于动态规划通过存储已解决子问题的结果来避免重复计算（利用了子问题的重叠性质），而分治在需要时会重新计算子问题的解。动态规划既可以自底向上也可以自顶向下（带备忘录的递归），两种方法都可以解决各种类型的问题。'  
    },  
    {  
        text: '在并查集（Union-Find）数据结构中，"路径压缩"技术的作用是什么？',  
        options: ['减少并查集占用的内存空间', '提高查找操作的效率', '加速合并操作', '防止数据损坏'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '路径压缩是并查集中的一种优化技术，用于提高查找操作的效率。在执行查找操作时，路径压缩会将路径上的所有节点直接连接到根节点，从而减少后续查找操作的路径长度。结合按秩合并技术，路径压缩能使并查集的操作接近常数时间复杂度。'  
    },  
    {  
        text: '如何判断单链表中是否存在环？',  
        options: ['使用哈希表记录已访问节点', '反转链表检查头尾', '快慢指针法（Floyd环检测算法）', '计算链表长度'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '快慢指针法（Floyd环检测算法）是判断链表是否有环的高效方法。该方法使用两个指针：慢指针每次移动一步，快指针每次移动两步。如果存在环，快指针最终会追上慢指针；如果没有环，快指针会先到达链表末尾。该方法的时间复杂度为O(n)，空间复杂度为O(1)，比使用哈希表的方法更节省空间。'  
    },  
    {  
        text: '在代码优化中，内联函数的主要优势是什么？',  
        options: ['减少程序的内存占用', '避免函数调用开销', '提高代码的可读性', '允许函数递归'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '内联函数的主要优势是避免函数调用的开销，如参数压栈、跳转、上下文保存和恢复等。编译器将内联函数的代码直接插入到调用点，而不是生成函数调用指令。这对于频繁调用的小函数特别有效。但内联会增加代码体积，所以需要在性能和空间之间权衡。'  
    },  
    {  
        text: '关于B树和B+树，以下说法正确的是？',  
        options: ['B树的所有关键字都存储在叶节点中', 'B+树的非叶节点不存储数据，只存储索引', 'B树的查询效率通常高于B+树', 'B+树不适合作为数据库索引结构'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'B+树的非叶节点只存储索引（键），不存储实际数据，所有数据都存储在叶节点中，且叶节点通过指针连接形成有序链表。而B树的非叶节点既存储索引也存储数据。B+树的这种结构特别适合数据库索引，因为它支持范围查询，且磁盘读取效率高。'  
    },  
    {  
        text: '以下哪种数据结构最适合实现操作系统的进程调度队列？',  
        options: ['栈', '单向链表', '优先队列', '哈希表'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '优先队列最适合实现操作系统的进程调度队列，特别是使用优先级调度算法时。优先队列可以根据进程的优先级自动组织元素，确保最高优先级的进程最先被处理。它可以通过堆（通常是二叉堆）高效实现，支持O(log n)的插入和删除最高优先级元素操作。'  
    },  
    {  
        text: '二叉搜索树在哪种情况下会退化成链表？',  
        options: ['随机插入元素时', '按照完全随机的顺序插入元素时', '按照升序或降序插入元素时', '使用中序遍历时'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '当按照升序或降序顺序插入元素时，二叉搜索树会退化成一个链表。例如，插入序列1,2,3,4,5会形成一个只有右子树的链状结构，每个节点都只有一个子节点。这种情况下，二叉搜索树的查找效率从O(log n)降为O(n)。这也是为什么需要自平衡二叉搜索树（如AVL树或红黑树）的原因。'  
    },  
    {  
        text: '计算斐波那契数列的最优时间复杂度是多少？',  
        options: ['O(2^n)', 'O(n log n)', 'O(n)', 'O(log n)'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '计算第n个斐波那契数的最优时间复杂度是O(n)，可以通过简单的循环迭代实现。虽然存在使用矩阵快速幂的O(log n)方法，但这通常只适用于计算单个非常大的斐波那契数，且实际中常数因子较大。普通递归方法的时间复杂度是O(2^n)，动态规划或备忘录方法是O(n)。'  
    },  
    {  
        text: '以下哪种排序算法的空间复杂度为O(1)？',  
        options: ['归并排序', '快速排序（最坏情况）', '堆排序', '基数排序'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '堆排序的空间复杂度是O(1)，因为它是原地排序算法，只需要常数额外空间用于交换元素。归并排序需要O(n)的额外空间用于归并操作；快速排序的最坏情况下递归深度为O(n)，导致O(n)的栈空间；基数排序通常需要额外的桶空间，空间复杂度为O(n+k)，其中k是桶的数量。'  
    },  
    {  
        text: '对于长度为n的数组，构建堆的时间复杂度是多少？',  
        options: ['O(n)', 'O(n log n)', 'O(log n)', 'O(n²)'],  
        correctAnswer: 'A',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '对于长度为n的数组，使用自底向上的方法构建堆的时间复杂度是O(n)，而不是直觉上的O(n log n)。这是因为叶子节点不需要向下调整，接近叶子的节点调整代价小，总体分析得到线性时间复杂度。这是堆排序算法的优势之一，虽然完整的堆排序过程是O(n log n)的。'  
    },  
    {  
        text: '拓扑排序算法适用于哪种类型的图？',  
        options: ['任何连通图', '无向图', '有向无环图', '完全图'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '拓扑排序算法仅适用于有向无环图(DAG)。它将图中的所有顶点排成一个线性序列，使得对于图中的每一条有向边(u,v)，顶点u在序列中都出现在顶点v之前。拓扑排序通常用于表示依赖关系的调度问题，如任务调度、编译顺序等。如果图中存在环，则无法得到有效的拓扑排序。'  
    },  
    {  
        text: '以下哪种算法可以解决任意两点间的最短路径问题？',  
        options: ['Dijkstra算法', 'Bellman-Ford算法', 'Floyd-Warshall算法', 'Kruskal算法'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'Floyd-Warshall算法可以解决任意两点间的最短路径问题（所有点对最短路径问题），时间复杂度为O(V³)。Dijkstra算法解决单源最短路径问题，但不适用于有负权边的图；Bellman-Ford算法也解决单源最短路径问题，可以处理负权边但不能处理负权环；Kruskal算法用于求最小生成树，不是计算最短路径的算法。'  
    },  
    {  
        text: '在图算法中，Kruskal算法和Prim算法都用于解决什么问题？',  
        options: ['单源最短路径问题', '所有点对最短路径问题', '最小生成树问题', '图着色问题'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'Kruskal算法和Prim算法都用于解决最小生成树(MST)问题，即在带权无向图中找到一棵包含所有顶点的树，使得树的总权重最小。Kruskal算法按边权重从小到大依次添加边（需要保证不形成环）；Prim算法从一个起始顶点开始，逐步扩展生成树。两种算法得到的最小生成树可能不同，但总权重相同。'  
    },  
    {  
        text: '以下哪种算法设计范式适合解决"背包问题"？',  
        options: ['分治法', '动态规划', '贪心算法', '回溯法'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '动态规划是解决背包问题的最佳方法，特别是0-1背包问题。通过定义状态dp[i][j]表示前i个物品放入容量为j的背包的最大价值，并构建状态转移方程，可以得到最优解。贪心算法只适用于特殊情况（如分数背包问题）；回溯法可行但效率低；分治法不适合解决此类问题。'  
    },  
    {  
        text: '关于哈希冲突的解决方法，以下说法错误的是？',  
        options: ['开放地址法包括线性探测、二次探测和双重哈希', '链地址法使用链表存储冲突的元素', '完美哈希函数可以完全避免冲突，适用于任何数据集', '再哈希法在冲突发生时使用另一个哈希函数'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '完美哈希函数只适用于已知且固定的数据集，不适用于任何数据集。理论上，对于任意动态变化的数据集，不可能设计出完全避免冲突的哈希函数。其他选项描述的都是正确的哈希冲突解决方法：开放地址法在哈希表中寻找其他位置；链地址法使用链表存储冲突元素；再哈希法使用备用哈希函数。'  
    },  
    {  
        text: '时间复杂度为O(n²)的排序算法通常在什么情况下优于O(n log n)的排序算法？',  
        options: ['数据量非常大时', '数据已经部分排序时', '数据量较小时', '需要稳定排序时'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '当数据量较小时，O(n²)的排序算法（如插入排序、冒泡排序）通常优于O(n log n)的排序算法（如快速排序、归并排序、堆排序）。这是因为O(n²)算法通常有更小的常数因子和低的实现复杂度，对于小数据集，这些因素的影响可能超过渐近时间复杂度的差异。此外，O(n²)算法通常有更好的局部性，这对缓存性能有利。'  
    },  
    {  
        text: '关于基数排序，以下说法正确的是？',  
        options: ['基数排序是一种比较排序算法', '基数排序的时间复杂度为O(n log n)', '基数排序适用于浮点数等所有数值类型', '基数排序的时间复杂度为O(d(n+k))，其中d是位数，k是基数'],  
        correctAnswer: 'D',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '基数排序是一种非比较排序算法，其时间复杂度为O(d(n+k))，其中d是位数，k是基数（比如十进制数的基数是10）。它通过逐位排序，从最低有效位到最高有效位，使用计数排序或桶排序作为子过程。基数排序主要适用于整数或固定格式的数据，对于浮点数等可能需要特殊处理。'  
    },  
    {  
        text: '在并发数据结构中，为什么无锁数据结构（lock-free data structures）比使用锁的数据结构更高效？',  
        options: ['无锁数据结构总是使用更少的内存', '无锁数据结构避免了锁导致的上下文切换和调度延迟', '无锁数据结构总是能保证公平的资源访问', '无锁数据结构的实现始终比加锁版本简单'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '无锁数据结构比使用锁的数据结构更高效主要是因为它避免了锁导致的上下文切换、调度延迟和优先级反转等问题。锁可能导致线程阻塞和唤醒，这涉及到操作系统的调度，带来显著的性能开销。无锁数据结构通常使用原子操作（如CAS）来实现线程安全，允许多个线程同时访问数据结构而不会互相阻塞。不过，无锁数据结构的实现通常比加锁版本更复杂，且不一定使用更少的内存。'  
    },  
    {  
        text: '在图的路径规划问题中，A*算法相比Dijkstra算法的主要优势是什么？',  
        options: ['A*算法可以处理负权边', 'A*算法总是找到最短路径', 'A*算法通过启发式函数减少搜索空间', 'A*算法不需要优先队列'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'A*算法相比Dijkstra算法的主要优势是通过启发式函数减少搜索空间，加速寻找最短路径的过程。A*算法在Dijkstra算法的基础上增加了启发式估计（如曼哈顿距离或欧几里得距离），使得搜索更倾向于朝目标方向前进，减少不必要的节点扩展。当启发式函数满足一定条件时，A*算法仍能保证找到最短路径。两种算法都不适合处理负权边，且都需要优先队列来实现。'  
    },  
    {  
        text: '以下哪种数据结构最适合实现缓存淘汰策略中的LFU（最不经常使用）算法？',  
        options: ['双端队列', '哈希表', '哈希表 + 堆', '栈 + 哈希表'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'LFU缓存淘汰策略需要跟踪每个元素的访问频率，并在缓存满时移除访问频率最低的元素。哈希表 + 堆的组合最适合实现LFU：哈希表提供O(1)的查找和更新操作，而最小堆可以在O(log n)时间内找到并移除访问频率最低的元素。其他数据结构组合难以同时高效支持这两种操作。实际实现中可能还需要额外的数据结构来处理访问频率相同时的情况（如按时间先后顺序）。'  
    },  
    {  
        text: '以下关于B-树的说法正确的是？',  
        options: ['B-树的所有叶子节点都位于同一层', 'B-树的每个节点最多有两个子节点', 'B-树的查找操作时间复杂度为O(n)', 'B-树主要用于内存数据结构'],  
        correctAnswer: 'A',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'B-树的所有叶子节点都位于同一层，这是B-树自平衡特性的一部分。B-树是多路搜索树，每个节点可以有多个子节点（不限于两个）；B-树的查找操作时间复杂度为O(log n)，而不是O(n)；B-树主要用于磁盘等外部存储系统，而不是内存数据结构，它的设计目标是减少磁盘I/O操作。'  
    },  
    {  
        text: '在给定的有向无环图(DAG)中，如何确定两个节点之间是否存在路径？',  
        options: ['只能使用深度优先搜索', '只能使用广度优先搜索', '可以使用拓扑排序检查', '使用Floyd-Warshall算法'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '在有向无环图(DAG)中，可以使用拓扑排序来确定两个节点之间是否存在路径。通过拓扑排序后，如果节点u在节点v之前出现，则可能存在从u到v的路径；如果u在v之后出现，则一定不存在从u到v的路径。当然，也可以使用DFS或BFS从起始节点开始搜索是否能到达目标节点，但拓扑排序提供了一种更系统的方法，特别是当需要检查多对节点时。Floyd-Warshall算法可用于所有点对最短路径，但对于单纯的可达性检查来说计算开销较大。'  
    },  
    {  
        text: '关于HashMap和HashTable，以下说法错误的是？',  
        options: ['HashTable是线程安全的，HashMap不是', 'HashMap允许null作为键和值，HashTable不允许', 'HashTable的方法是同步的，可能导致性能问题', 'HashMap的性能总是比HashTable差'],  
        correctAnswer: 'D',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '说法"HashMap的性能总是比HashTable差"是错误的。实际上，在单线程环境或不需要线程安全保证的场景下，HashMap的性能通常优于HashTable，因为HashMap没有同步开销。其他说法都是正确的：HashTable是线程安全的，而HashMap不是；HashMap允许null作为键和值，而HashTable不允许；HashTable的方法是同步的，这可能导致竞争条件下的性能问题。'  
    },  
    {  
        text: '以下哪种算法适用于求解图的最大流问题？',  
        options: ['Dijkstra算法', 'Ford-Fulkerson算法', 'Kruskal算法', 'Floyd-Warshall算法'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'Ford-Fulkerson算法（及其改进版如Edmonds-Karp算法）适用于求解图的最大流问题。该算法通过不断寻找增广路径并增加流量，直到无法找到更多增广路径为止。Dijkstra算法用于单源最短路径问题；Kruskal算法用于最小生成树问题；Floyd-Warshall算法用于所有点对最短路径问题。最大流问题在网络流量分配、交通规划等领域有广泛应用。'  
    },  
    {  
        text: '分治算法的基本思想是什么？',  
        options: ['将问题拆分为子问题，解决子问题后合并结果', '按照问题的某种贪心策略逐步构建解决方案', '通过避免重复计算子问题提高效率', '尝试所有可能的解决方案找到最优解'],  
        correctAnswer: 'A',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '分治算法（Divide and Conquer）的基本思想是将原问题分解为若干个规模较小但类似于原问题的子问题，递归地解决这些子问题，然后再合并这些子问题的解来建立原问题的解。经典的分治算法包括归并排序、快速排序、二分查找等。选项B描述的是贪心算法，选项C描述的是动态规划，选项D描述的是穷举法或回溯法。'  
    },  
    {  
        text: '线程安全的单例模式实现通常使用什么技术？',  
        options: ['简单的同步方法', '双重检查锁定 + volatile', '枚举类型', '以上都是'],  
        correctAnswer: 'D',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '线程安全的单例模式可以通过多种方式实现：1) 简单的同步方法，如在getInstance()方法上添加synchronized关键字；2) 双重检查锁定(DCL) + volatile，减少同步开销；3) 使用枚举类型，这是最简洁的实现方式，自动提供线程安全和序列化机制。这些方法都能确保在多线程环境下只创建单例类的一个实例，但在性能和实现复杂度上有所不同。'  
    },  
    {  
        text: '对于大规模数据排序，磁盘上的外部排序通常使用什么策略？',  
        options: ['快速排序', '基数排序', '归并排序的变体', '堆排序'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '大规模数据的外部排序通常使用归并排序的变体。典型的策略是将数据分割成能装入内存的块，对每个块在内存中排序（可以用任何高效的内部排序算法），然后将排序好的块写回磁盘，最后合并这些有序块（多路归并）。这种方法对磁盘I/O特别友好，因为它主要是顺序访问，而不是随机访问。快速排序和堆排序不太适合外部排序，因为它们涉及大量的随机访问；基数排序可能适用于某些特定类型的数据，但通常不是首选。'  
    },  
    {  
        text: '以下哪种算法可以在不需要预先知道数组大小的情况下，找到数组中的众数（出现次数超过n/2的元素）？',  
        options: ['排序后取中间元素', '哈希表计数', 'Boyer-Moore投票算法', '二分查找'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'Boyer-Moore投票算法可以在O(n)时间和O(1)空间复杂度内找到数组的众数（出现次数超过n/2的元素），且不需要预先知道数组大小。该算法设置计数器和候选元素，遍历数组时根据当前元素是否等于候选元素更新计数器，计数器为0时更换候选元素。排序需要O(n log n)时间；哈希表计数需要O(n)空间；二分查找不适用于此问题。'  
    },  
    {  
        text: '关于平衡二叉搜索树的自平衡操作，以下说法正确的是？',  
        options: ['旋转操作会改变树中节点之间的相对顺序', '左旋和右旋操作的计算复杂度是O(n)', 'AVL树比红黑树需要更多的平衡操作', '旋转操作会影响树的中序遍历结果'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'AVL树确实比红黑树需要更多的平衡操作，因为AVL树的平衡条件更严格（任意节点的两个子树高度差不超过1），而红黑树的条件相对宽松。因此，AVL树在插入和删除操作后更频繁地需要旋转来维持平衡。旋转操作不会改变树中节点的相对顺序，不会影响中序遍历的结果（仍然是有序的），且其计算复杂度是O(1)，不是O(n)。'  
    },  
    {  
        text: '以下哪种技术可以有效地减少递归算法的栈空间使用？',  
        options: ['增加基本情况的数量', '尾递归优化', '增加递归调用的次数', '使用更多的局部变量'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '尾递归优化是减少递归算法栈空间使用的有效技术。在尾递归中，递归调用是函数的最后一个操作，且不对递归调用的结果执行任何额外操作。编译器可以将尾递归优化为迭代形式，从而避免为每个递归调用分配新的栈帧，使空间复杂度从O(n)降为O(1)。增加基本情况的数量或递归调用次数通常不会减少栈空间使用，增加局部变量反而会增加每个栈帧的大小。'  
    },  
    {  
        text: '在位运算中，表达式 (x & (x-1)) 的作用是什么？',  
        options: ['将x的最高位1变为0', '将x的最低位1变为0', '检查x是否是2的幂', '计算x中1的个数'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '表达式 (x & (x-1)) 的作用是将x的二进制表示中的最低位1变为0。例如，如果x = 10110，则x-1 = 10101，x & (x-1) = 10100。这个操作在计算机科学中非常有用，可以用来：1) 检查一个数是否是2的幂（如果结果为0，则是2的幂）；2) 计算一个数的二进制表示中1的个数（每次操作都会消除一个1，重复直到x为0并计数）；3) 某些位操作算法中作为基本操作。'  
    },  
    {  
        text: '以下哪种算法可以用于检测有向图中的环？',  
        options: ['广度优先搜索', '深度优先搜索 + 标记访问状态', 'Kruskal算法', 'Dijkstra算法'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '深度优先搜索(DFS)配合标记节点访问状态是检测有向图中环的有效方法。具体来说，在DFS过程中，节点有三种状态：未访问、访问中（已发现但未完全探索）和已访问（完全探索）。如果在DFS过程中遇到一个"访问中"的节点，说明存在环。这种方法时间复杂度为O(V+E)。广度优先搜索不适合直接检测环；Kruskal算法用于最小生成树；Dijkstra算法用于最短路径。'  
    },  
    {  
        text: '如何优化大数据量下的排序算法性能？',  
        options: ['总是使用快速排序', '根据数据特征选择合适的排序算法', '优先使用基于比较的排序算法', '避免使用外部排序'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '优化大数据量下的排序算法性能应根据数据特征选择合适的排序算法。例如，对于部分有序的数据可能选择插入排序或TimSort；对于范围有限的整数可以使用计数排序或基数排序；对于非常大的数据可能需要外部排序。没有一种排序算法在所有情况下都是最优的。此外，根据实际需求可能还需要考虑稳定性、内存使用等因素。'  
    },  
    {  
        text: '以下哪个数据结构最适合实现前缀树（Trie）？',  
        options: ['链表数组', '哈希表数组', '二维数组', '堆'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '前缀树（Trie）最适合使用哈希表数组实现。在Trie中，每个节点需要存储到其子节点的链接，使用哈希表数组可以实现O(1)的子节点查找时间，并且只需要为实际存在的子节点分配空间。链表数组也可以用于实现Trie，但查找效率较低；二维数组会浪费大量空间；堆不适合表示树的这种分支结构。前缀树主要用于字符串的快速查找、前缀匹配和自动补全等应用。'  
    },  
    {  
        text: '在多线程编程中，哪种同步原语可以允许多个读者同时访问共享资源，但写者必须独占？',  
        options: ['互斥锁(Mutex)', '读写锁(Read-Write Lock)', '信号量(Semaphore)', '条件变量(Condition Variable)'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '读写锁(Read-Write Lock)专门设计用于允许多个读者同时访问共享资源，但要求写者必须独占访问。这种机制适合于读操作远多于写操作的场景，可以显著提高并发性能。互斥锁(Mutex)不区分读写操作，同一时间只允许一个线程访问共享资源；信号量(Semaphore)可以控制同时访问资源的线程数量，但通常不区分读写操作；条件变量(Condition Variable)用于线程间的通知机制，通常与互斥锁配合使用。'  
    },  
    {  
        text: '以下哪种排序算法是原地排序（不需要额外空间）且稳定的？',  
        options: ['快速排序', '归并排序', '冒泡排序', '堆排序'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '冒泡排序是原地排序（空间复杂度O(1)）且稳定的排序算法。它通过重复遍历数组，比较相邻元素并交换顺序不对的元素对，直到整个数组排序完成。快速排序是原地排序但不稳定；标准的归并排序需要O(n)额外空间，虽然稳定但不是原地的；堆排序是原地排序但不稳定。排序算法的选择需要根据数据特性、稳定性要求和可用资源等因素综合考虑。'  
    },  
    {  
        text: '下面关于KMP字符串匹配算法的描述，哪个是错误的？',  
        options: ['KMP算法的时间复杂度是O(m+n)，其中m是模式串长度，n是文本串长度', 'KMP算法使用了"部分匹配表"来跳过不必要的比较', 'KMP算法在最坏情况下比朴素字符串匹配算法效率低', 'KMP算法的核心思想是利用已经匹配的信息避免重复比较'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '说法"KMP算法在最坏情况下比朴素字符串匹配算法效率低"是错误的。实际上，KMP算法在最坏情况下的时间复杂度是O(m+n)，优于朴素算法的O(m*n)。KMP算法通过预处理模式串构建"部分匹配表"，使得在匹配失败时能够利用已获得的部分匹配信息跳过一些不必要的比较，从而提高效率。KMP算法是字符串匹配领域的经典算法，尤其适合处理有大量重复模式的文本。'  
    },  
    {  
        text: '缓存替换策略中，哪种算法在理论上能达到最佳效果（最少缺页）？',  
        options: ['FIFO（先进先出）', 'LRU（最近最少使用）', 'LFU（最不经常使用）', 'OPT（最优页面置换）'],  
        correctAnswer: 'D',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'OPT（最优页面置换）算法在理论上能达到最佳效果，产生最少的缺页中断。OPT算法的原则是替换最长时间内不会被访问的页面。然而，OPT算法需要预知未来的访问序列，实际上是不可实现的，主要用作理论上的参考标准。FIFO替换最早进入的页面；LRU替换最长时间未被访问的页面；LFU替换访问次数最少的页面。这些都是实际可实现的算法，但在不同场景下效果各异，无法在所有情况下达到OPT的理论最优效果。'  
    },  
    {  
        text: '以下哪种数据结构最适合实现LRU（最近最少使用）缓存？',  
        options: ['链表', '优先队列', '哈希表', '哈希表 + 双向链表'],  
        correctAnswer: 'D',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '哈希表 + 双向链表是实现LRU缓存的最佳数据结构组合。哈希表提供O(1)时间复杂度的查询操作，而双向链表允许在O(1)时间内删除和添加节点，便于维护元素的访问顺序。当一个元素被访问时，可以迅速找到它（通过哈希表）并将其移到链表头部（表示最近使用）；当缓存满时，可以从链表尾部移除最久未使用的元素。单独使用链表、优先队列或哈希表都无法高效支持LRU缓存所需的所有操作。'  
    },  
    {  
        text: '在代码优化中，"循环不变量外提"技术的主要目的是什么？',  
        options: ['减少内存使用', '提高缓存命中率', '减少重复计算', '简化循环结构'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '"循环不变量外提"（Loop-invariant code motion）是一种优化技术，其主要目的是减少重复计算。它将循环内每次迭代都计算相同结果的表达式移到循环外只计算一次，从而减少计算量。例如，将`for(int i=0; i<n; i++) { x = y*z + w; a[i] = x + i; }`优化为`x = y*z + w; for(int i=0; i<n; i++) { a[i] = x + i; }`。这种优化尤其适用于循环次数较多的情况。它也可能提高缓存命中率和简化循环结构，但这些通常是次要效果。'  
    },  
    {  
        text: '在以下算法中，哪个最适合在大规模、有许多重复元素的数据集上进行排序？',  
        options: ['快速排序', '插入排序', '计数排序', '堆排序'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '计数排序最适合在大规模、有许多重复元素的数据集上进行排序。计数排序是一种非比较排序算法，它使用额外的计数数组统计每个元素出现的次数，然后直接计算每个元素在排序数组中的位置。当数据范围相对较小且有大量重复元素时，计数排序的时间复杂度为O(n+k)（其中k是数据范围），可以优于O(n log n)的比较排序算法。快速排序和堆排序的最优时间复杂度为O(n log n)；插入排序对于大规模数据效率较低，时间复杂度为O(n²)。'  
    },  
    {  
        text: '在链表操作中，如何在O(1)时间内删除给定节点（假设已知节点指针，但不知道头节点）？',  
        options: ['这是不可能的，删除链表节点必须从头开始遍历', '将目标节点标记为已删除，实际上不移除它', '将下一个节点的值复制到当前节点，然后删除下一个节点', '交换目标节点与头节点，然后删除头节点'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '在不知道头节点的情况下，可以通过将下一个节点的值复制到当前节点，然后删除下一个节点的方式在O(1)时间内"删除"给定节点。例如，要删除链表A->B->C->D中的节点B，我们将C的值复制到B，然后将B的next指向D，相当于删除了原来的B节点（虽然实际删除的是C节点）。这种方法的限制是不适用于尾节点，因为没有下一个节点可复制；也可能因为节点中包含复杂数据而不适用。标记删除不是真正的删除；从头遍历需要O(n)时间；交换与头节点通常也需要知道头节点位置。'  
    },  
    {  
        text: '关于跳表（Skip List），以下说法正确的是？',  
        options: ['跳表是一种随机化的数据结构，用于有序序列的快速查找', '跳表的查找、插入和删除操作的平均时间复杂度都是O(n)', '跳表比红黑树实现简单，但空间效率更低', '跳表只适用于整数数据'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '跳表比红黑树实现简单，但空间效率确实更低，这是因为跳表需要存储多级索引。跳表是一种随机化的数据结构，用于有序序列的快速查找、插入和删除，这些操作的平均时间复杂度都是O(log n)，而不是O(n)。跳表适用于任何可比较的数据类型，不限于整数。跳表的主要优势是实现简单且支持并发操作，在某些场景（如Redis中的有序集合）被广泛应用。'  
    },  
    {  
        text: '在计算机网络中，使用一个32位整数作为IP地址，把主机位全部置为1表示什么？',  
        options: ['网络地址', '主机地址', '广播地址', 'DNS服务器地址'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '在IP地址中，把主机位全部置为1表示广播地址。广播地址用于向子网内所有主机发送数据包。例如，对于子网192.168.1.0/24（前24位是网络号），广播地址是192.168.1.255，其中主机位（最后8位）全为1。网络地址是主机位全为0的地址（如192.168.1.0）；主机地址是分配给特定主机的地址；DNS服务器地址是指定的DNS服务器IP地址，与位模式无关。'  
    },  
    {  
        text: '关于布隆过滤器（Bloom Filter），以下说法错误的是？',  
        options: ['布隆过滤器可能产生假阳性（误报）', '布隆过滤器不支持删除元素', '布隆过滤器可以确定元素一定存在集合中', '布隆过滤器的空间效率比传统的集合数据结构高'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '说法"布隆过滤器可以确定元素一定存在集合中"是错误的。实际上，布隆过滤器只能告诉我们两种可能性：元素可能在集合中，或者元素一定不在集合中。当布隆过滤器返回元素可能存在时，这可能是假阳性（实际不存在但被误报为存在）。其他说法都是正确的：布隆过滤器确实可能产生假阳性；标准布隆过滤器不支持删除元素（有变体如计数布隆过滤器可以支持）；布隆过滤器的空间效率比传统集合数据结构高，但代价是引入一定的错误率。'  
    },  
    {  
        text: '使用位运算优化乘法时，表达式 x << n 等价于什么？',  
        options: ['x * (2^n)', 'x * n', 'x / (2^n)', 'x ^ n'],  
        correctAnswer: 'A',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '位运算表达式 x << n（将x左移n位）等价于 x * (2^n)。左移操作在二进制表示中将所有位向左移动n位，低位用0填充，这相当于将数值乘以2的n次方。例如，5 << 2 = 5 * (2^2) = 5 * 4 = 20。同理，右移操作(x >> n)在处理无符号数时等价于 x / (2^n)。这种位运算优化可以在某些情况下提高性能，因为移位操作通常比乘除法更快。'  
    },  
    {  
        text: '关于哈希函数的设计，以下哪项不是理想哈希函数的特性？',  
        options: ['输出分布均匀', '计算速度快', '抗碰撞性强', '单射（不同输入一定产生不同输出）'],  
        correctAnswer: 'D',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '单射（不同输入一定产生不同输出）不是理想哈希函数的必要特性，实际上对于任意哈希函数这是不可能的，因为输入空间通常远大于输出空间（鸽巢原理）。理想的哈希函数应具有均匀分布的输出（减少冲突）、快速的计算速度（提高性能）和良好的抗碰撞性（难以找到产生相同哈希值的不同输入）。在实际应用中，根据具体需求可能还要考虑其他特性，如抗预映射性（难以从哈希值反推原始数据）等。'  
    },  
    {  
        text: '以下哪种数据结构适合实现图的邻接表表示？',  
        options: ['数组', '链表数组', '哈希表', '二维数组'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '链表数组最适合实现图的邻接表表示。在邻接表中，我们为每个顶点维护一个链表，存储与该顶点相邻的所有顶点。这种表示法对于稀疏图（边数远小于顶点数的平方）特别高效，因为它只存储实际存在的边。使用链表数组，我们可以通过数组索引快速访问任何顶点的邻接表，并通过链表高效地添加和删除边。纯数组不适合表示变长的邻接关系；哈希表可用但查找效率不如数组；二维数组适合邻接矩阵表示而非邻接表。'  
    },  
    {  
        text: '在操作系统内存管理中，页表的主要作用是什么？',  
        options: ['防止内存泄漏', '记录内存使用情况', '将虚拟地址转换为物理地址', '优化内存访问速度'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '页表的主要作用是将虚拟地址转换为物理地址。在分页内存管理系统中，程序使用虚拟地址空间，而实际内存使用物理地址空间。页表存储了虚拟页号到物理页帧号的映射关系，使操作系统能够正确地将程序的虚拟地址转换为实际的物理内存地址。这种机制实现了内存隔离、共享和保护，也支持了虚拟内存技术（使用磁盘空间扩展可用内存）。防止内存泄漏主要是程序设计的责任；记录内存使用情况通常由其他内存管理组件完成；虽然有TLB等机制优化内存访问速度，但这不是页表的主要作用。'  
    },  
    {  
        text: '关于并查集（Union-Find）数据结构，以下说法正确的是？',  
        options: ['查找操作的最坏时间复杂度是O(n)', '使用路径压缩和按秩合并后，操作的均摊时间复杂度接近于常数', '并查集主要用于图的最短路径问题', '并查集不支持合并操作'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '并查集使用路径压缩和按秩合并优化后，操作的均摊时间复杂度确实接近于常数（理论上是O(α(n))，其中α是阿克曼函数的反函数，增长极其缓慢）。未优化的并查集查找操作的最坏时间复杂度确实是O(n)，但随着优化技术的应用会大大改善。并查集主要用于解决动态连通性问题、等价类划分等，不是专门用于图的最短路径问题。并查集的核心操作就包括合并（Union）和查找（Find），因此它当然支持合并操作。'  
    },  
    {  
        text: '在函数式编程中，什么是"纯函数"？',  
        options: ['不含任何循环的函数', '不修改任何全局变量的函数', '给定相同输入总是产生相同输出且没有副作用的函数', '使用递归而不是迭代的函数'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '纯函数是指给定相同的输入总是产生相同的输出，且没有副作用的函数。副作用包括修改全局变量、修改传入的参数、执行I/O操作等。纯函数的特性使得代码更容易理解、测试和并行化。不含循环、不修改全局变量或使用递归都不足以定义纯函数，虽然纯函数通常具有其中一些特性。函数式编程强调使用纯函数作为主要构建块，但也可以在其他编程范式中应用纯函数的概念。'  
    },  
    {  
        text: '关于虚拟内存技术，以下说法错误的是？',  
        options: ['虚拟内存允许程序使用比物理内存更大的地址空间', '页面置换算法（如LRU）用于决定应将哪个页面从内存移出', '虚拟内存技术完全消除了程序的内存限制', '虚拟内存可以为每个进程提供独立的地址空间'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '说法"虚拟内存技术完全消除了程序的内存限制"是错误的。虚拟内存确实扩展了可用内存，允许程序使用比物理内存更大的地址空间，但它并没有完全消除内存限制。虚拟内存仍受到地址空间大小（如32位系统的4GB限制）、可用磁盘空间和性能考虑的约束。过度依赖虚拟内存（频繁页面交换）会导致"颠簸"现象，严重影响系统性能。其他说法都是正确的：虚拟内存确实允许使用比物理内存更大的地址空间，使用页面置换算法管理内存页面，并为每个进程提供独立的地址空间。'  
    },  
    {  
        text: '在代码优化中，"软件流水线"技术的主要目的是什么？',  
        options: ['减少函数调用次数', '优化循环执行，利用指令级并行', '降低内存使用', '改善输入/输出操作效率'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '软件流水线（Software Pipelining）技术的主要目的是优化循环执行，利用指令级并行性。这种技术重新安排循环指令执行顺序，使得循环的不同迭代的指令可以重叠执行，充分利用现代处理器的流水线特性和多发射能力。软件流水线通常作为编译器优化的一部分实现，可以显著提高循环密集型程序的性能。它主要影响指令调度而不是减少函数调用、降低内存使用或改善I/O效率。'  
    },  
    {  
        text: '缓存友好的算法设计主要考虑什么因素？',  
        options: ['减少算法中的分支条件', '最小化时间复杂度', '优化内存访问模式，提高局部性', '减少总体操作次数'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '缓存友好的算法设计主要考虑优化内存访问模式，提高数据的局部性（时间局部性和空间局部性）。这种设计充分利用计算机内存层次结构，使得程序频繁访问的数据更可能留在缓存中，从而减少高延迟的内存访问。具体策略包括：顺序访问数据（而非随机访问）、合适的数据结构选择、数据布局优化、缓存阻塞（分块处理）等。虽然减少分支条件、降低时间复杂度和减少操作次数也是优化目标，但缓存优化特别关注内存访问模式，有时甚至会增加操作次数来换取更好的缓存性能。'  
    },  
    {  
        text: '使用整数代替浮点数计算，主要的性能优势是什么？',  
        options: ['整数运算总是比浮点运算更准确', '整数乘法和除法运算通常比浮点运算快', '整数比浮点数占用更少的内存', '整数运算不会产生溢出错误'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '整数乘法和除法运算通常比浮点运算快，这是使用整数代替浮点数计算的主要性能优势。在大多数处理器上，整数运算单元比浮点运算单元更简单、更快。此外，有些处理器（特别是嵌入式系统）可能没有专门的浮点硬件，需要通过软件模拟浮点运算，这会进一步扩大性能差距。但需注意：整数运算不一定比浮点运算更准确（精度取决于问题和实现）；整数和浮点数（如int和float）在许多系统上占用相同内存；整数同样会产生溢出错误。在实际应用中，应根据精度需求和性能考虑权衡选择。'  
    },  
    {  
        text: '在多线程编程中，什么是"原子操作"？',  
        options: ['必须由操作系统执行的操作', '不能被优化的操作', '一个不可分割的操作，执行过程中不会被其他线程干扰', '只能访问共享内存的操作'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '原子操作是指一个不可分割的操作，它要么完全执行，要么完全不执行，在执行过程中不会被其他线程干扰或观察到中间状态。原子操作是实现线程安全的基础，常见的原子操作包括原子读、原子写、比较并交换(CAS)等。原子操作不一定由操作系统执行，许多处理器提供硬件级的原子指令；原子操作可以被优化，只要保持其原子性；原子操作可以访问局部或共享内存。'  
    },  
    {  
        text: '在计算机性能优化中，什么是"False Sharing"（伪共享）问题？',  
        options: ['错误地共享私有数据导致的安全问题', '缓存行共享导致的性能问题', '线程间错误通信导致的逻辑错误', '使用未初始化变量导致的随机行为'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'False Sharing（伪共享）是一个缓存行共享导致的性能问题。当不同线程访问的不同变量恰好位于同一缓存行（cache line）时，即使这些变量逻辑上相互独立，一个线程对其变量的修改也会导致整个缓存行失效，迫使其他线程重新从内存加载数据，从而显著降低性能。解决方法包括填充变量（使其占用单独的缓存行）或重新组织数据结构避免共享缓存行。伪共享是多核系统中的常见性能瓶颈，尤其影响高并发应用。'  
    },  
	</script>
    <script>  
        function quizApp() {  
            return {  
                // 题目数据
                questions: [],
                
                answeredCount: 0,  
                correctCount: 0,  
                incorrectCount: 0,  
                accuracyRate: 0,  

                init() {
                    // 从script标签获取问题数据
                    const questionsScript = document.getElementById('questionData');
                    if (questionsScript) {
                        try {
                            const questionsText = questionsScript.textContent;
                            // 将文本内容转换为有效的JSON格式
                            const jsonText = '[' + questionsText + ']';
                            
                            // 解析JSON并初始化问题
                            this.questions = eval(jsonText);
                        } catch (e) {
                            console.error("Error parsing questions: ", e);
                            this.questions = [];
                        }
                    }
                },
                
                checkAnswer(index) {  
                    const question = this.questions[index];  
                    if (question.userAnswer) {  
                        question.checked = true;  
                        
                        // 只有第一次检查时才计入总数  
                        if (!question.counted) {  
                            this.answeredCount++;  
                            question.counted = true;  
                            
                            if (question.userAnswer === question.correctAnswer) {  
                                this.correctCount++;  
                            } else {  
                                this.incorrectCount++;  
                            }  
                        }  
                        
                        this.calculateAccuracy();  
                    }  
                },  
                
                calculateAccuracy() {  
                    if (this.answeredCount > 0) {  
                        this.accuracyRate = Math.round((this.correctCount / this.answeredCount) * 100);  
                    }  
                },  
                
                scrollToQuestion(questionNum) {  
                    const element = document.getElementById('question-' + questionNum);  
                    if (element) {  
                        element.scrollIntoView({ behavior: 'smooth' });  
                    }  
                },  
                
                getJumpButtonClass(questionNum) {  
                    // 检查该区域内的题目是否已回答  
                    let allAnswered = true;  
                    let anyAnswered = false;  
                    let allCorrect = true;  
                    
                    for (let i = questionNum; i < questionNum + 5 && i <= this.questions.length; i++) {  
                        if (this.questions[i-1] && this.questions[i-1].counted) {  
                            anyAnswered = true;  
                            if (this.questions[i-1].userAnswer !== this.questions[i-1].correctAnswer) {  
                                allCorrect = false;  
                            }  
                        } else {  
                            allAnswered = false;  
                        }  
                    }  
                    
                    if (allAnswered && allCorrect) return 'bg-green-500 text-white';  
                    if (allAnswered) return 'bg-green-100 text-green-800';  
                    if (anyAnswered) return 'bg-yellow-100 text-yellow-800';  
                    return 'bg-gray-100 text-gray-800';  
                },  
                
                printResults() {  
                    // 首先强制检查所有已回答但未检查的题目  
                    this.questions.forEach((question, index) => {  
                        if (question.userAnswer && !question.checked) {  
                            this.checkAnswer(index);  
                        }  
                    });  
                    
                    // 然后打印页面  
                    window.print();  
                }  
            }  
        }  
    </script>  
</body>  
</html>
