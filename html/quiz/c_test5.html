
<!DOCTYPE html>  
<html lang="zh-CN">  
<head>  
    <meta charset="UTF-8">  
    <meta name="viewport" content="width=device-width, initial-scale=1.0">  
    <title>C语言测验 - linux操作系统</title>  
    <!-- 本地样式和脚本文件 -->  
    <link href="../tailwind.min.css" rel="stylesheet">  
    <script src="../alpine.min.js" defer></script>  
    <style>  
        .question {  
            border-bottom: 1px solid #e2e8f0;  
            padding-bottom: 1.5rem;  
            margin-bottom: 1.5rem;  
        }  
        .correct {  
            color: #059669;  
            font-weight: bold;  
        }  
        .incorrect {  
            color: #dc2626;  
            font-weight: bold;  
        }  
        .explanation {  
            background-color: #f8fafc;  
            border-left: 4px solid #3b82f6;  
            padding: 1rem;  
            margin-top: 1rem;  
        }  
        .sidebar {  
            position: sticky;  
            top: 20px;  
            height: calc(100vh - 40px);  
            overflow-y: auto;  
        }  
        @media print {  
            .no-print {  
                display: none;  
            }  
            .print-break {  
                page-break-before: always;  
            }  
        }  
    </style>  
</head>  
<body class="bg-gray-50">  
    <div x-data="quizApp()" class="container mx-auto px-4 py-8">  
        <header class="text-center mb-10">  
            <div class="mx-auto w-24 h-24 mb-4">  
                <svg viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">  
                    <path d="M70 20H30C24.4772 20 20 24.4772 20 30V70C20 75.5228 24.4772 80 30 80H70C75.5228 80 80 75.5228 80 70V30C80 24.4772 75.5228 20 70 20Z" fill="#3B82F6"/>  
                    <path d="M50 25C36.1929 25 25 36.1929 25 50C25 63.8071 36.1929 75 50 75C63.8071 75 75 63.8071 75 50C75 36.1929 63.8071 25 50 25Z" fill="white"/>  
                    <path d="M50 30C38.9543 30 30 40.9543 30 55C30 69.0457 38.9543 80 50 80C61.0457 80 70 69.0457 70 55C70 40.9543 61.0457 30 50 30Z" fill="#3B82F6"/>  
                    <text x="50" y="60" font-family="Arial" font-size="24" font-weight="bold" fill="white" text-anchor="middle">C</text>  
                    <path d="M75 30H80L85 35V40H80V35H75V30Z" fill="#FFA55F"/>  
                    <path d="M25 70H20L15 65V60H20V65H25V70Z" fill="#FFA55F"/>  
                </svg>  
            </div>  
            <h1 class="text-3xl font-bold text-gray-800">C语言编程测验之操作系统测试题100</h1>  
            <p class="text-gray-600 mt-2">共100道选择题，答题后点击"检查答案"查看结果和解析</p>  
        </header>  

        <div class="flex flex-col md:flex-row gap-8">  
            <!-- 左侧边栏：固定进度和统计信息 -->  
            <div class="w-full md:w-1/4 lg:w-1/5 no-print">  
                <div class="sidebar bg-white rounded-lg shadow-md p-4">  
                    <h2 class="text-lg font-medium text-gray-900 mb-4">测验进度</h2>  
                    
                    <div class="progress-bar mb-6">  
                        <div class="flex justify-between mb-1">  
                            <span class="text-sm font-medium text-blue-700">完成题目</span>  
                            <span class="text-sm font-medium text-blue-700" x-text="answeredCount + ' / ' + questions.length"></span>  
                        </div>  
                        <div class="w-full bg-gray-200 rounded-full h-2.5">  
                            <div class="bg-blue-600 h-2.5 rounded-full" :style="'width: ' + (answeredCount / questions.length * 100) + '%'"></div>  
                        </div>  
                    </div>  
                    
                    <div class="stats space-y-4 mb-8">  
                        <div class="stat bg-gray-50 rounded-lg p-3">  
                            <div class="text-sm text-gray-600">正确答案</div>  
                            <div class="text-2xl font-bold text-green-600" x-text="correctCount"></div>  
                        </div>  
                        <div class="stat bg-gray-50 rounded-lg p-3">  
                            <div class="text-sm text-gray-600">错误答案</div>  
                            <div class="text-2xl font-bold text-red-600" x-text="incorrectCount"></div>  
                        </div>  
                        <div class="stat bg-gray-50 rounded-lg p-3">  
                            <div class="text-sm text-gray-600">准确率</div>  
                            <div class="text-2xl font-bold text-blue-600" x-text="accuracyRate + '%'"></div>  
                        </div>  
                    </div>  
                    
                    <div class="jump-to-section">  
                        <h3 class="text-md font-medium text-gray-900 mb-2">快速跳转</h3>  
                        <div class="grid grid-cols-5 gap-1">  
                            <template x-for="i in 20">  
                                <button class="py-1 text-xs rounded hover:bg-blue-100"   
                                        :class="getJumpButtonClass((i-1)*5+1)"  
                                        @click="scrollToQuestion((i-1)*5+1)">  
                                    <span x-text="(i-1)*5+1"></span>-<span x-text="i*5"></span>  
                                </button>  
                            </template>  
                        </div>  
                    </div>  
                    
                    <div class="mt-8">  
                        <button @click="printResults()" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded">  
                            打印测验结果  
                        </button>  
                    </div>  
                </div>  
            </div>  
            
            <!-- 右侧主要内容：题目列表 -->  
            <div class="w-full md:w-3/4 lg:w-4/5">  
                <div class="bg-white rounded-lg shadow-md p-6">  
                    <template x-for="(question, index) in questions" :key="index">  
                        <div class="question" :id="'question-' + (index + 1)" :class="{'print-break': index > 0 && index % 5 === 0}">  
                            <h3 class="text-lg font-medium text-gray-900 mb-2">  
                                <span x-text="(index + 1) + '.'"></span>  
                                <span x-html="question.text"></span>  
                            </h3>  
                            <div class="options grid grid-cols-1 md:grid-cols-2 gap-2 mb-4">  
                                <template x-for="(option, optIndex) in ['A', 'B', 'C', 'D']" :key="optIndex">  
                                    <div class="flex items-start">  
                                        <input type="radio" :id="'q' + (index + 1) + option" :name="'question' + (index + 1)" :value="option"   
                                               x-model="question.userAnswer"   
                                               class="mt-1 mr-2">  
                                        <label :for="'q' + (index + 1) + option" class="text-gray-700" x-html="question.options[optIndex]"></label>  
                                    </div>  
                                </template>  
                            </div>  
                            <div class="flex items-center">  
                                <button @click="checkAnswer(index)"   
                                        class="bg-blue-600 hover:bg-blue-700 text-white font-medium py-1 px-4 rounded no-print"  
                                        :disabled="question.checked"  
                                        :class="{'opacity-50 cursor-not-allowed': question.checked}">  
                                    检查答案  
                                </button>  
                                <div x-show="question.checked" class="ml-4" :class="question.userAnswer === question.correctAnswer ? 'correct' : 'incorrect'">  
                                    <span x-show="question.userAnswer === question.correctAnswer">✓ 正确答案！</span>  
                                    <span x-show="question.userAnswer !== question.correctAnswer">✗ 错误。正确答案是: <span x-text="question.correctAnswer"></span></span>  
                                </div>  
                            </div>  
                            <div x-show="question.checked && question.explanation" class="explanation mt-2" x-html="question.explanation"></div>  
                        </div>  
                    </template>  
                </div>  
            </div>  
        </div>  
    </div>  

    <!-- 这里是关键修改：使用script标签定义问题数据 -->
    <script id="questionData" type="text/plain">
  
    {  
        text: '在Linux系统中，open()系统调用的主要功能是什么？',  
        options: ['打开一个已存在的文件或创建一个新文件', '读取文件内容', '写入文件内容', '关闭已打开的文件'],  
        correctAnswer: 'A',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'open()系统调用用于打开一个已存在的文件或创建一个新文件，返回一个文件描述符。这个文件描述符是后续对该文件进行读、写和其他操作的引用标识。'  
    },  
    {  
        text: '以下哪个系统调用用于从已打开的文件读取数据？',  
        options: ['write()', 'read()', 'open()', 'close()'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'read()系统调用用于从文件描述符引用的文件中读取数据到指定的缓冲区。其基本形式为：ssize_t read(int fd, void *buf, size_t count)，其中fd是文件描述符，buf是接收数据的缓冲区，count是要读取的字节数。'  
    },  
    {  
        text: '关于ioctl()系统调用，以下描述正确的是？',  
        options: ['专门用于网络编程', '用于对设备进行控制操作', '只能用于终端设备', '替代了read()和write()的功能'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'ioctl()系统调用是一个通用的接口，用于对设备进行控制操作，特别是那些不能通过普通文件操作（如read、write）完成的任务。它可以用于各种设备，包括但不限于终端设备、网络设备、磁盘设备等。'  
    },  
    {  
        text: '在Linux中，设置文件权限可以使用哪个系统调用？',  
        options: ['open()', 'chmod()', 'chown()', 'access()'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'chmod()系统调用用于更改文件的访问权限。它可以设置文件的读、写、执行权限，以及特殊权限如setuid、setgid和sticky位。其基本形式为：int chmod(const char *pathname, mode_t mode)。'  
    },  
    {  
        text: 'umask()函数的主要作用是什么？',  
        options: ['设置文件的访问权限', '获取进程的用户ID', '设置进程创建文件时的默认权限屏蔽值', '获取文件的所有者'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'umask()函数用于设置进程创建文件时的默认权限屏蔽值。当进程创建新文件或目录时，这些文件的初始权限会受到umask值的影响。umask值中的位为1表示相应的权限位被屏蔽（不授予）。'  
    },  
    {  
        text: '以下哪个函数用于获取当前进程的实际用户ID？',  
        options: ['getpid()', 'geteuid()', 'getuid()', 'getgid()'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'getuid()函数用于获取调用进程的实际用户ID（real user ID）。实际用户ID通常是启动进程的用户的ID。相比之下，geteuid()返回有效用户ID（effective user ID），getpid()返回进程ID，getgid()返回实际组ID。'  
    },  
    {  
        text: 'setuid()的主要功能是什么？',  
        options: ['设置文件的所有者', '设置进程的有效用户ID', '设置文件的setuid位', '设置用户的登录密码'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'setuid()函数用于设置调用进程的有效用户ID。如果进程拥有适当的权限（通常是root权限），它可以将其有效用户ID更改为任何值。这在需要临时提升或降低权限的场景中非常有用。'  
    },  
    {  
        text: '在Linux信号处理中，signal()函数的主要作用是什么？',  
        options: ['发送信号给其他进程', '阻塞特定信号', '为指定信号设置处理函数', '等待信号的到达'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'signal()函数用于为指定的信号设置处理函数。当进程接收到该信号时，会调用指定的处理函数而不是执行默认操作。虽然signal()在早期UNIX系统中很常用，但现代Linux程序通常更推荐使用更强大和可靠的sigaction()函数。'  
    },  
    {  
        text: '相比signal()函数，sigaction()的主要优势是什么？',  
        options: ['更高的执行效率', '更精细的信号控制和更可靠的行为', '可以处理更多类型的信号', '不需要包含头文件'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'sigaction()相比signal()提供了更精细的信号控制和更可靠的行为。它允许指定信号处理的各种选项，如是否阻塞其他信号、是否自动重启被中断的系统调用等。sigaction()的行为在不同UNIX系统间更一致，而signal()的行为可能因系统而异。'  
    },  
    {  
        text: 'SIGINT信号通常由什么操作触发？',  
        options: ['程序执行非法内存访问', '用户在终端按下Ctrl+C', '子进程终止', '程序执行除以零操作'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'SIGINT（中断信号）通常由用户在终端按下Ctrl+C组合键触发。它的默认行为是终止进程。程序可以捕获这个信号并执行清理操作，也可以完全忽略它（虽然不建议这样做）。'  
    },  
    {  
        text: 'SIGSEGV信号表示什么？',  
        options: ['段错误（非法内存访问）', '浮点异常', '终端挂起', '用户自定义信号'],  
        correctAnswer: 'A',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'SIGSEGV表示段错误（Segmentation Fault），通常是由程序尝试访问无效的内存地址（如空指针解引用、访问已释放的内存、数组越界等）导致的。其默认行为是终止进程并生成核心转储文件（如果系统配置允许）。'  
    },  
    {  
        text: 'Linux内核中的系统调用主要通过什么机制实现？',  
        options: ['中断机制', '轮询', '直接函数调用', '消息队列'],  
        correctAnswer: 'A',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'Linux内核中的系统调用主要通过中断机制实现。用户程序通过特殊的指令（如x86的SYSCALL指令）触发一个从用户态到内核态的转换，这个过程涉及到特定的硬件中断或异常。内核接收到中断后，根据系统调用号执行相应的内核函数，然后返回用户态。'  
    },  
    {  
        text: '在Linux内核模块开发中，模块的初始化函数通常用什么宏进行注册？',  
        options: ['module_init()', 'kernel_init()', 'init_module()', 'start_module()'],  
        correctAnswer: 'A',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'module_init()宏用于注册模块的初始化函数，这个函数在模块加载时执行。类似地，module_exit()宏用于注册模块的清理函数，在模块卸载时执行。这些宏是Linux内核模块编程的标准方式，定义在<linux/module.h>头文件中。'  
    },  
    {  
        text: '以下哪个命令用于加载Linux内核模块？',  
        options: ['modprobe', 'insmod', 'lsmod', 'rmmod'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'insmod命令用于加载指定的内核模块。例如：insmod mymodule.ko。它直接加载模块文件，不会自动处理依赖关系。相比之下，modprobe命令更智能，它会处理模块依赖关系，在需要时自动加载依赖模块；lsmod用于列出当前加载的模块；rmmod用于卸载模块。'  
    },  
    {  
        text: '大端序（Big Endian）的特点是什么？',  
        options: ['低位字节存储在内存的低地址', '高位字节存储在内存的低地址', '字节序由CPU动态决定', '所有字节存储在同一地址'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '大端序（Big Endian）的特点是高位字节存储在内存的低地址，低位字节存储在高地址。例如，十六进制数0x12345678在大端序中的存储顺序是：0x12 0x34 0x56 0x78。这种方式更符合人类阅读习惯，常见于SPARC、PowerPC等架构。'  
    },  
    {  
        text: '网络字节序采用的是哪种字节序？',  
        options: ['小端序', '大端序', '取决于操作系统', '取决于网络协议'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '网络字节序统一采用大端序（Big Endian），这是TCP/IP协议标准规定的。这意味着在网络数据传输前，可能需要在小端序计算机上将数据从主机字节序转换为网络字节序，这就是htonl、htons等函数的用途。统一使用大端序简化了不同架构计算机间的通信。'  
    },  
    {  
        text: '以下哪个函数用于将主机字节序的短整型(16位)转换为网络字节序？',  
        options: ['htonl()', 'ntohl()', 'htons()', 'ntohs()'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'htons()函数用于将主机字节序的短整型(16位)转换为网络字节序。函数名可以理解为"host to network short"。类似地，htonl()用于32位长整型，ntohs()和ntohl()则用于相反方向的转换（从网络字节序到主机字节序）。在大端序机器上，这些函数可能是空操作，而在小端序机器上，会执行实际的字节交换。'  
    },  
    {  
        text: '以下哪种方法可以用来检测系统的字节序？',  
        options: ['调用操作系统API', '编译时确定', '使用联合体检测', '读取CPU文档'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '使用联合体检测是一种常用的运行时检测系统字节序的方法。例如：union { uint16_t value; uint8_t bytes[2]; } test; test.value = 0x0102; if(test.bytes[0] == 0x01) printf("大端序"); else printf("小端序");。这种方法利用联合体在内存中的布局，通过检查同一内存位置的不同解释方式来确定字节序。'  
    },  
    {  
        text: '在Linux进程优先级中，Nice值的范围是多少？',  
        options: ['-20到19', '0到99', '1到139', '-100到100'],  
        correctAnswer: 'A',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'Linux中用户态进程的Nice值范围是-20到19，其中-20表示最高优先级，19表示最低优先级。默认的Nice值通常是0。可以使用nice或renice命令调整进程的Nice值，普通用户只能增加Nice值（降低优先级），而root用户可以任意调整。'  
    },  
    {  
        text: '在Linux内核实时优先级中，数值大小与优先级的关系是什么？',  
        options: ['数值越大，优先级越低', '数值越大，优先级越高', '数值与优先级无关', '取决于调度策略'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '在Linux内核实时优先级中，数值越大，优先级越高。实时优先级的范围是1到99，其中99是最高优先级。这与用户态的Nice值正好相反（Nice值越小，优先级越高）。实时优先级通常用于SCHED_FIFO和SCHED_RR调度策略下的任务。'  
    },  
    {  
        text: 'SCHED_FIFO调度策略的特点是什么？',  
        options: ['时间片轮转', '按比例分配CPU时间', '先到先服务，直到任务主动放弃CPU', '动态调整优先级'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'SCHED_FIFO（先进先出）调度策略的特点是：高优先级任务会一直运行，直到主动让出CPU（如阻塞、调用sched_yield()或被高优先级任务抢占）。同优先级任务按队列顺序执行，先到的任务独占CPU。这种策略不使用时间片，适合需要确定性响应的实时任务。'  
    },  
    {  
        text: 'SCHED_RR调度策略与SCHED_FIFO的主要区别是什么？',  
        options: ['不考虑优先级', '可以被非实时任务抢占', '使用时间片，防止同优先级任务长时间独占CPU', '只能用于特权进程'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'SCHED_RR（轮转调度）与SCHED_FIFO的主要区别是：SCHED_RR对同优先级的任务使用时间片轮转机制，当一个任务用完其时间片后，调度器会将其放到同优先级队列的尾部，从而防止单一任务长时间独占CPU。这种机制在保持实时性的同时提高了公平性。'  
    },  
    {  
        text: '在Linux中，进程状态"D"表示什么？',  
        options: ['运行状态', '可中断睡眠', '不可中断睡眠', '僵尸进程'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '在Linux中，进程状态"D"表示不可中断睡眠（Uninterruptible Sleep）。这种状态下的进程正在等待硬件I/O操作完成，不能被信号（包括SIGKILL）中断。如果系统中有长时间处于D状态的进程，可能表示硬件或驱动程序出现问题。'  
    },  
    {  
        text: '僵尸进程（Zombie）的特点是什么？',  
        options: ['占用大量CPU资源', '无法被终止', '已终止但父进程未回收其资源', '正在等待子进程结束'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '僵尸进程（状态为"Z"）是已经终止但其父进程尚未调用wait()或waitpid()等函数回收其资源的进程。僵尸进程不占用CPU或内存资源，但会占用一个进程ID（PID）。如果系统中积累了大量僵尸进程，可能导致无法创建新进程，因为PID用尽。'  
    },  
    {  
        text: '进程切换和线程切换的主要区别是什么？',  
        options: ['进程切换更快', '线程切换需要切换地址空间', '进程切换不需要保存寄存器状态', '线程切换不需要切换地址空间'],  
        correctAnswer: 'D',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '线程切换不需要切换地址空间，因为同一进程的线程共享地址空间。这是线程切换相比进程切换更轻量级的主要原因。进程切换需要切换CR3寄存器（指向页表）并刷新TLB，而线程切换只需要保存和恢复寄存器状态。因此，线程切换的开销通常比进程切换小很多。'  
    },  
    {  
        text: '以下哪个函数用于在Linux内核中创建内核线程？',  
        options: ['pthread_create()', 'fork()', 'kthread_create()', 'create_thread()'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'kthread_create()函数用于在Linux内核中创建内核线程。创建后，线程处于停止状态，需要使用wake_up_process()函数启动它。或者可以使用kthread_run()函数，它结合了创建和启动操作。内核线程完全运行在内核空间，没有用户空间上下文。'  
    },  
    {  
        text: '在/proc/meminfo中，"MemFree"表示什么？',  
        options: ['物理内存总量', '可用于分配的内存', '已被使用的内存', '交换空间大小'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '/proc/meminfo中的"MemFree"表示当前系统中未被使用，可直接用于分配的物理内存。需要注意的是，Linux系统通常会将空闲内存用于文件系统缓存，因此实际可用内存应该考虑"MemFree"、"Buffers"和"Cached"的总和。'  
    },  
    {  
        text: 'Linux内存管理中，buddy系统的主要功能是什么？',  
        options: ['管理虚拟内存', '分配连续的物理页框', '管理用户空间内存', '处理页面交换'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'Buddy系统是Linux内核中用于分配连续物理页框的机制。它将空闲内存按2的幂次大小分组，当需要分配内存时，找到满足大小要求的最小块；当释放内存时，尝试与相邻的"伙伴"合并成更大的块。这种算法简单高效，但可能导致内部碎片。'  
    },  
    {  
        text: 'DMA内存的特殊之处是什么？',  
        options: ['速度特别快', '容量特别大', '可以被设备直接访问而无需CPU干预', '只能被内核访问'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'DMA（直接内存访问）内存的特殊之处在于它可以被外设直接访问而无需CPU干预。在执行DMA操作时，设备控制器可以直接将数据传输到内存或从内存读取数据，同时CPU可以执行其他任务。这大大提高了I/O操作的效率。在某些架构上，DMA内存需要满足特定的硬件限制（如地址限制）。'  
    },  
    {  
        text: 'kmalloc()和vmalloc()的主要区别是什么？',  
        options: ['kmalloc分配虚拟内存，vmalloc分配物理内存', 'kmalloc分配的内存总是物理连续的，vmalloc不保证物理连续', 'kmalloc只能在中断上下文使用，vmalloc不能', 'kmalloc分配的内存更大'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'kmalloc()和vmalloc()的主要区别是：kmalloc()分配的内存在物理上是连续的（适合DMA操作或需要物理连续内存的场景），而vmalloc()只保证虚拟地址连续，物理地址可能不连续。因此，vmalloc()可以分配较大的内存块，但访问速度可能略慢（因为可能增加TLB未命中）。两者都分配内核空间的虚拟内存。'  
    },  
    {  
        text: 'malloc()和calloc()的区别是什么？',  
        options: ['malloc分配虚拟内存，calloc分配物理内存', 'malloc不初始化内存，calloc将内存初始化为零', 'malloc只能分配固定大小，calloc可变大小', 'malloc线程安全，calloc不是'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'malloc()和calloc()的主要区别是：malloc()分配指定大小的内存块但不初始化内容（包含垃圾值），而calloc()分配指定数量的元素，每个元素指定大小，并将所有位初始化为零。此外，calloc()的参数形式不同：void *calloc(size_t nmemb, size_t size)，表示分配nmemb个size大小的元素。'  
    },  
    {  
        text: '页表（Page Table）的主要功能是什么？',  
        options: ['管理物理内存分配', '将虚拟地址转换为物理地址', '控制进程的内存访问权限', '管理磁盘交换空间'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '页表的主要功能是将虚拟地址转换为物理地址。在分页内存管理系统中，每个进程有自己的页表，记录了该进程虚拟地址空间中的页面到物理内存页框的映射关系。当程序访问内存时，处理器使用页表将程序使用的虚拟地址转换为实际的物理地址。页表也存储了访问权限和其他属性信息。'  
    },  
    {  
        text: 'TLB（Translation Lookaside Buffer）的作用是什么？',  
        options: ['加速文件系统访问', '加速网络数据传输', '加速虚拟地址到物理地址的转换', '加速进程切换'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'TLB（转译后备缓冲器）是一种特殊的硬件缓存，用于加速虚拟地址到物理地址的转换过程。它存储最近使用的页表条目，使处理器在大多数情况下不必访问内存中的页表来获取地址映射。TLB利用了程序的局部性原理，显著提高了内存访问速度。'  
    },  
    {  
        text: '内存屏障（Memory Barrier）的主要作用是什么？',  
        options: ['防止未授权的内存访问', '同步多个处理器或核心之间的内存访问', '限制进程的内存使用量', '检测内存泄漏'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '内存屏障是一种同步原语，用于同步多个处理器或核心之间的内存访问。在现代处理器中，为了提高性能，内存操作可能被重新排序或缓存在处理器本地。内存屏障确保在屏障之前的内存操作对所有处理器可见，并且完成后才执行屏障之后的操作。这在多处理器系统和无锁编程中非常重要。'  
    },  
    {  
        text: '以下哪种锁适合短时间持有且竞争不激烈的场景？',  
        options: ['互斥锁（Mutex）', '自旋锁（Spinlock）', '读写锁（RW Lock）', '信号量（Semaphore）'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '自旋锁适合短时间持有且竞争不激烈的场景。自旋锁在等待获取锁时会持续检查锁的状态（"自旋"），而不是将线程挂起，这避免了上下文切换的开销。但如果锁被长时间持有，自旋会浪费CPU周期。因此，自旋锁最适合保护短临界区（通常在内核中），且预期等待时间短。'  
    },  
    {  
        text: '互斥锁（Mutex）和信号量（Semaphore）的主要区别是什么？',  
        options: ['互斥锁速度更快', '信号量可以由一个线程获取、另一个线程释放', '互斥锁只能用于线程间，信号量可用于进程间', '互斥锁限制资源访问为独占式，信号量可以允许多个线程并发访问'],  
        correctAnswer: 'D',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '互斥锁和信号量的主要区别是：互斥锁是二元的（只有锁定和解锁两种状态），限制对资源的访问为独占式；而信号量可以有任意非负整数值，可以设置为允许多个线程同时访问资源（如设置为5表示最多5个线程可以同时访问）。信号量更通用，可以解决更多同步问题，而互斥锁专注于互斥问题。'  
    },  
    {  
        text: 'GNU C中的container_of宏的主要用途是什么？',  
        options: ['动态分配内存', '类型转换', '根据结构体成员指针获取结构体指针', '计算数组大小'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'container_of宏用于根据结构体成员的指针获取包含该成员的结构体指针。其典型用法是：container_of(ptr, type, member)，其中ptr是指向结构体成员的指针，type是结构体类型，member是成员名。这在内核编程中很有用，特别是在实现通用数据结构（如链表）时，可以从链表节点指针恢复包含该节点的完整结构体。'  
    },  
    {  
        text: 'GNU C中的typeof操作符的作用是什么？',  
        options: ['检查变量的类型是否正确', '创建新的类型', '获取表达式的类型', '将变量转换为指定类型'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'typeof操作符用于获取表达式的类型，它是GNU C的扩展，不是标准C的一部分。typeof使得编写更通用的宏成为可能，因为它可以处理任何类型的变量，而不需要显式指定类型。例如：#define max(a,b) ({ typeof(a) _a = (a); typeof(b) _b = (b); _a > _b ? _a : _b; })，这个宏可以处理任何可比较类型。'  
    },  
    {  
        text: 'offsetof宏的功能是什么？',  
        options: ['计算指针偏移量', '计算数组索引', '计算结构体成员相对于结构体起始位置的字节偏移量', '计算函数参数的偏移量'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'offsetof宏用于计算结构体成员相对于结构体起始位置的字节偏移量。其定义在<stddef.h>中，用法为：offsetof(type, member)。这个宏在需要手动计算内存布局时非常有用，例如在序列化结构体、实现自定义内存分配或进行底层内存操作时。'  
    },  
    {  
        text: '以下哪个是正确使用GNU C语言连接符（##）的例子？',  
        options: ['#define CONCAT(a, b) a ## b', '#define CONCAT(a, b) a + b', '#define CONCAT(a, b) "a" "b"', '#define CONCAT(a, b) a; b;'],  
        correctAnswer: 'A',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '#define CONCAT(a, b) a ## b是正确使用GNU C语言连接符（##）的例子。连接符（##）用在预处理阶段，将两个标记连接成一个新标记。例如，CONCAT(foo, bar)会被预处理为foobar。这在需要生成变量名或函数名时特别有用，如在实现泛型数据结构或API时。'  
    },  
    {  
        text: '变参宏（Variadic Macros）中的__VA_ARGS__表示什么？',  
        options: ['变量参数的个数', '变量参数的类型', '变量参数本身', '变量参数的地址'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '在变参宏中，__VA_ARGS__表示变量参数本身（所有可变参数的集合）。例如：#define debug(format, ...) printf(format, __VA_ARGS__)。当调用debug("Value: %d", 10)时，预处理器会将其展开为printf("Value: %d", 10)。这使得创建灵活的宏变得更容易，特别是用于调试、日志记录等场景。'  
    },  
    {  
        text: '在字符设备驱动程序中，主设备号和次设备号的作用是什么？',  
        options: ['主设备号标识设备类型，次设备号区分同类设备中的不同单元', '主设备号表示优先级，次设备号表示功能', '主设备号用于块设备，次设备号用于字符设备', '主设备号和次设备号共同构成设备的唯一标识符'],  
        correctAnswer: 'A',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '在Linux设备驱动模型中，主设备号用于标识设备的类型或对应的驱动程序，次设备号用于区分同一类型设备中的不同单元或实例。例如，所有终端设备可能共享同一个主设备号，但每个终端有不同的次设备号。内核使用主设备号查找相应的驱动程序，然后将次设备号传递给驱动程序的操作函数。'  
    },  
    {  
        text: '在Linux文件系统中，i-node（索引节点）存储了哪些信息？',  
        options: ['仅文件内容', '仅文件名和路径', '文件元数据（如权限、大小、时间戳）和指向数据块的指针', '仅文件类型'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'i-node（索引节点）存储了文件的元数据和指向实际数据块的指针。元数据包括：文件类型（普通文件、目录、链接等）、权限、所有者和组ID、文件大小、访问/修改/创建时间戳、链接计数等。i-node不存储文件名，文件名存储在目录条目中。这种设计使得硬链接成为可能（多个文件名可以指向同一个i-node）。'  
    },  
    {  
        text: '以下哪项不是Linux VFS（虚拟文件系统）的主要功能？',  
        options: ['提供统一的文件操作接口', '管理物理存储设备', '协调不同文件系统的差异', '维护打开文件的状态'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'Linux VFS的主要功能不包括管理物理存储设备。VFS是一个抽象层，提供统一的文件操作接口，使应用程序可以用相同的方式访问不同类型的文件系统。它协调不同文件系统的差异，维护打开文件的状态，但不直接管理物理存储设备——这是底层具体文件系统和块设备驱动的责任。'  
    },  
    {  
        text: '在Linux中，软链接（Symbolic Link）和硬链接（Hard Link）的主要区别是什么？',  
        options: ['软链接可以跨文件系统，硬链接不行', '软链接是新建一个文件，硬链接不是', '软链接的权限总是与原文件相同', '软链接占用更多磁盘空间'],  
        correctAnswer: 'A',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '软链接和硬链接的主要区别是：软链接可以跨文件系统，而硬链接只能在同一文件系统内创建。这是因为硬链接是对同一个i-node的多个目录引用，而不同文件系统有各自独立的i-node表。软链接创建一个新的i-node，其中存储了目标路径，类似于Windows的快捷方式。此外，软链接可以指向目录，硬链接不能；如果原文件被删除，软链接失效，硬链接仍然可用（直到所有硬链接都被删除）。'  
    },  
    {  
        text: 'Linux内核中，块设备和字符设备的主要区别是什么？',  
        options: ['块设备支持随机访问，字符设备只支持顺序访问', '块设备由硬件实现，字符设备由软件实现', '块设备只能读取，字符设备可读可写', '块设备不需要驱动程序'],  
        correctAnswer: 'A',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '块设备和字符设备的主要区别是：块设备支持随机访问，数据以固定大小的块为单位传输（如硬盘、U盘）；而字符设备通常只支持顺序访问，数据以字符流的形式传输（如键盘、串口）。块设备通常有缓冲机制，而字符设备通常没有。两种设备都需要驱动程序，也都可以是硬件或软件实现的，通常都支持读写操作（取决于具体设备）。'  
    },  
    {  
        text: 'PCIe设备的特点是什么？',  
        options: ['只支持低速传输', '点对点串行连接，支持高速数据传输', '只能用于显卡', '不支持热插拔'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'PCIe（PCI Express）设备的主要特点是点对点串行连接，支持高速数据传输。与并行的PCI相比，PCIe采用串行通信，每个设备有专用的通信通道（通过交换机连接），避免了共享总线的瓶颈。PCIe支持多种设备（不仅是显卡），如网卡、存储控制器、声卡等。更高版本的PCIe规范也支持热插拔功能。'  
    },  
    {  
        text: '以下哪个不是自旋锁的特点？',  
        options: ['等待获取锁时会持续尝试（自旋）', '适合保护短临界区', '被阻塞时会让出CPU', '可在中断上下文中使用'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '自旋锁的一个关键特点是等待时不会让出CPU，这与选项C相反。自旋锁在等待获取锁时会持续尝试（自旋），这意味着线程保持活动状态并消耗CPU周期。自旋锁适合保护短临界区，因为长时间自旋会浪费CPU资源。它们可以在中断上下文中使用，因为不会导致休眠（互斥锁可能导致休眠，因此不适合中断上下文）。'  
    },  

 
    {  
        text: '以下哪个系统调用可以改变文件的当前位置？',  
        options: ['read()', 'write()', 'lseek()', 'stat()'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'lseek()系统调用用于改变文件的当前读写位置（文件偏移量）。它可以将文件位置设置为绝对位置，或者相对于当前位置或文件末尾的相对位置。基本形式为：off_t lseek(int fd, off_t offset, int whence)，其中whence可以是SEEK_SET（从文件开始）、SEEK_CUR（从当前位置）或SEEK_END（从文件末尾）。'  
    },  
    {  
        text: '在Linux内核中，tasklet的主要特点是什么？',  
        options: ['可以被抢占', '在硬中断上下文中运行', '在进程上下文中运行', '可以休眠'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'tasklet在硬中断上下文中运行，是Linux内核延迟中断处理机制的一部分。tasklet不能被它自己类型的其他实例抢占，但可以被其他类型的中断处理程序抢占。由于运行在中断上下文中，tasklet不能休眠，也不能访问用户空间。tasklet适合处理不需要严格实时性且处理时间较短的工作。'  
    },  
    {  
        text: 'Linux内核中，软中断（Softirq）的特点是什么？',  
        options: ['可以休眠', '运行在进程上下文中', '高优先级，可以抢占普通进程', '只能由用户空间触发'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '软中断是高优先级任务，可以抢占普通进程，但不能抢占硬中断处理程序。软中断运行在中断上下文中，不能休眠，也不能访问用户空间。软中断主要由内核触发（如硬中断处理程序、进程等），而不是由用户空间触发。软中断通常用于处理网络数据包、定时器等对延迟敏感的任务。'  
    },  
    {  
        text: 'Linux内核中，工作队列（Workqueue）相比软中断和tasklet的主要优势是什么？',  
        options: ['更高的优先级', '可以休眠', '更低的延迟', '可以访问硬件'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '工作队列的主要优势是可以休眠。工作队列中的函数运行在进程上下文中（而不是中断上下文），因此可以休眠、阻塞以及使用可能导致阻塞的内核API。这使得工作队列适合执行可能需要等待资源的较长时间任务。相比之下，软中断和tasklet运行在中断上下文中，不能休眠，因此适合短时间、不阻塞的任务。'  
    },  
    {  
        text: 'slab分配器在Linux内核中的主要作用是什么？',  
        options: ['管理用户空间内存', '分配连续物理页框', '高效分配固定大小的内核对象', '管理进程地址空间'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'slab分配器的主要作用是高效分配固定大小的内核对象。它在buddy系统之上构建，通过对象缓存和内存复用减少了内存碎片和分配/释放开销。slab非常适合频繁分配和释放相同大小对象的场景，如创建和销毁socket、inode等内核数据结构。slab分配器只用于内核空间，不管理用户空间内存或进程地址空间。'  
    },  
    {  
        text: 'ioremap()函数在Linux内核中的作用是什么？',  
        options: ['分配DMA内存', '将物理内存地址映射到内核虚拟地址空间', '将用户空间地址映射到内核空间', '重新映射页表'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'ioremap()函数用于将物理内存地址映射到内核的虚拟地址空间，使内核代码能够访问这些物理地址。这在访问内存映射I/O设备的寄存器时特别有用。例如，当驱动程序需要访问设备的控制寄存器时，可以使用ioremap()将这些寄存器所在的物理地址映射到内核虚拟地址空间，然后通过返回的虚拟地址进行读写操作。'  
    },  
    {  
        text: '在Linux中，对共享内存进行原子操作的正确方式是？',  
        options: ['使用普通变量操作', '使用atomic_t类型和相应的原子操作函数', '在多处理器系统上无法实现原子操作', '总是使用互斥锁'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '在Linux中，对共享内存进行原子操作的正确方式是使用atomic_t类型和相应的原子操作函数，如atomic_inc()、atomic_dec()、atomic_add()等。这些操作保证在多处理器系统上也是原子的，不会被中断或抢占。虽然互斥锁也可以保护共享内存，但对于简单的计数器或标志位，原子操作通常更高效。普通变量操作在多处理器或抢占式内核中不是原子的。'  
    },  
    {  
        text: '什么是Linux内核中的RCU（Read-Copy-Update）机制？',  
        options: ['一种文件系统', '一种同步原语，允许多个读者同时访问，而无需锁定', '一种网络协议', '一种进程调度算法'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'RCU（Read-Copy-Update）是Linux内核中的一种同步原语，特别适合读多写少的场景。RCU允许多个读者无锁并发访问，而写者则创建被共享数据的新副本，修改后再替换原数据（通过原子指针更新）。旧数据只有在确保没有读者使用它后才会释放。RCU显著提高了读密集场景的性能，被广泛用于内核数据结构如链表、树等的并发访问。'  
    },  
    {  
        text: '在Linux中，mmap()系统调用的主要用途是什么？',  
        options: ['创建新进程', '分配动态内存', '将文件或设备映射到进程的地址空间', '进行进程间通信'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'mmap()系统调用的主要用途是将文件或设备映射到进程的地址空间。这样，进程可以通过内存访问操作直接读写文件内容，而不需要使用read()或write()系统调用，从而减少了数据复制和系统调用开销。mmap()也可用于匿名映射（不对应任何文件），这时它类似于动态内存分配。此外，多个进程可以映射同一个文件，实现共享内存形式的进程间通信。'  
    },  
    {  
        text: '在Linux信号处理中，哪些信号默认是不能被捕获或忽略的？',  
        options: ['所有信号都可以被捕获', 'SIGKILL和SIGSTOP', 'SIGHUP和SIGTERM', 'SIGINT和SIGSEGV'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'SIGKILL（信号9）和SIGSTOP（信号19）默认是不能被捕获、阻塞或忽略的。这是操作系统故意设计的，目的是确保系统管理员始终有办法终止或暂停进程，即使进程试图屏蔽所有信号。SIGKILL用于立即终止进程，SIGSTOP用于暂停进程执行。其他信号，如SIGHUP、SIGTERM、SIGINT和SIGSEGV，都可以被捕获和处理（虽然某些情况如严重的内存访问错误可能导致SIGSEGV无法被有效处理）。'  
    },  
    {  
        text: '在多线程程序中，线程特定数据（Thread Specific Data，TSD）的作用是什么？',  
        options: ['共享数据给所有线程', '为每个线程提供独立的数据副本', '限制线程的内存使用', '提高线程优先级'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '线程特定数据（TSD）的作用是为每个线程提供独立的数据副本。在多线程程序中，全局变量对所有线程可见，而局部变量只在函数执行期间有效。TSD填补了这个空白，允许每个线程拥有自己的数据实例，同时通过相同的变量名访问。这在线程需要自己的状态信息（如错误码、事务ID等）时非常有用。在POSIX线程库中，可以使用pthread_key_create()、pthread_setspecific()和pthread_getspecific()函数管理TSD。'  
    },  
    {  
        text: '在Linux中，epoll相比select和poll的主要优势是什么？',  
        options: ['支持更多文件描述符', '更低的CPU使用率，尤其在大量文件描述符但只有少量活动的情况下', '更简单的API', '更好的跨平台兼容性'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'epoll相比select和poll的主要优势是更低的CPU使用率，尤其在监视大量文件描述符但只有少量活动的情况下。select和poll每次调用都需要遍历所有监视的文件描述符，而epoll采用事件通知机制，只返回活动的描述符。此外，epoll没有文件描述符数量的固定限制（select有FD_SETSIZE限制），API功能更强大（支持边缘触发和水平触发）。不过，epoll是Linux特有的，不具备跨平台兼容性。'  
    },  
    {  
        text: '在Linux信号处理中，为什么在信号处理函数中应该小心使用哪些函数？',  
        options: ['因为信号处理函数运行在内核态', '因为信号处理函数可能在任何时刻中断主程序，导致不可重入函数的问题', '因为信号处理函数总是在进程终止前执行', '因为信号处理函数不能访问全局变量'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '在信号处理函数中应该小心使用某些函数，因为信号处理函数可能在任何时刻中断主程序，包括主程序正在执行不可重入函数的时刻。如果信号处理函数也调用这些不可重入函数，可能导致数据结构损坏或其他不可预期的行为。不可重入函数通常包括使用静态数据结构或调用malloc/free的函数，如printf、strtok等。信号处理函数应尽量简短，只使用异步信号安全的函数（在POSIX标准中定义）。'  
    },  
    {  
        text: '在Linux进程间通信中，哪种方式适合传输大量数据？',  
        options: ['信号（signals）', '命名管道（FIFO）', '共享内存（shared memory）', '消息队列（message queues）'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '共享内存是传输大量数据的最佳进程间通信方式，因为数据无需在进程间复制。进程可以直接访问映射到其地址空间的共享内存区域，提供了最高的数据传输效率。信号主要用于通知事件，不适合传输数据；命名管道和消息队列适合传输小到中等量的数据，但数据需要从发送进程复制到内核再复制到接收进程，对大量数据传输效率较低。注意，共享内存通常需要配合信号量等同步机制使用，以协调多进程对共享数据的访问。'  
    },  
    {  
        text: '在Linux中，fork()系统调用创建新进程后，子进程和父进程的主要区别是什么？',  
        options: ['子进程获得全新的地址空间，不共享任何内容', '子进程的进程ID、父进程ID和某些资源（如打开的文件描述符）与父进程不同', '子进程只能执行预定义的一组系统调用', '子进程总是比父进程优先级低'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'fork()创建的子进程与父进程几乎完全相同，但有一些关键区别：子进程有新的进程ID和父进程ID，某些资源如挂起的信号和定时器不被继承。子进程获得父进程内存页的副本（通过写时复制机制优化），共享打开的文件描述符（除非设置了FD_CLOEXEC标志）。子进程有完整的执行能力，可以执行任何系统调用，优先级也默认与父进程相同。fork()后通常跟随exec()调用，用新程序替换子进程的内存映像。'  
    },  
    {  
        text: '什么是Linux中的Copy-on-Write（写时复制）机制？',  
        options: ['一种文件系统备份策略', '一种网络数据包复制技术', '一种内存优化策略，内存页只在被修改时才实际复制', '一种进程通信方式'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'Copy-on-Write（写时复制）是Linux的内存优化策略，特别是在fork()调用中使用。当fork()创建子进程时，子进程不会立即获得父进程内存页的完整副本，而是与父进程共享这些页（标记为只读）。只有当任一进程尝试修改共享页时，内核才会创建该页的副本。这大大提高了fork()的效率，特别是在fork()后立即执行exec()的常见情况下（如在shell中运行命令），因为大部分内存页可能永远不需要复制。'  
    },  
    {  
        text: '以下哪个函数组合可以防止多进程同时访问临界区？',  
        options: ['fork() 和 wait()', 'open() 和 close()', 'semget() 和 semop()', 'signal() 和 kill()'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'semget()和semop()函数是System V IPC信号量操作的基本函数，可以用来防止多进程同时访问临界区。semget()创建或访问一个信号量集，而semop()执行信号量操作（如P/V操作，也称为wait/signal或lock/unlock）。在进入临界区前，进程使用semop()对信号量执行减操作（P操作）；在离开临界区后，执行增操作（V操作）。如果信号量已被减至0，尝试进一步减少的进程会被阻塞，直到其他进程增加信号量。'  
    },  
    {  
        text: '在POSIX线程库中，条件变量（condition variable）的主要用途是什么？',  
        options: ['替代互斥锁保护共享数据', '在线程间传递数据', '允许线程等待特定条件发生', '限制同时运行的线程数量'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '条件变量的主要用途是允许线程等待特定条件发生。条件变量总是与互斥锁配合使用：线程首先获取互斥锁，检查条件，如果条件不满足，调用pthread_cond_wait()等待（此函数会原子性地释放互斥锁并阻塞线程）；当另一个线程改变条件并调用pthread_cond_signal()或pthread_cond_broadcast()时，等待的线程被唤醒，重新获取互斥锁并再次检查条件。条件变量解决了轮询（不断检查条件）带来的CPU浪费问题。'  
    },  
    {  
        text: '在Linux内核中，自旋锁（spinlock）和读写自旋锁（rwlock）的区别是什么？',  
        options: ['自旋锁只能在单处理器系统使用，读写自旋锁可在多处理器系统使用', '自旋锁适用于短临界区，读写自旋锁适用于长临界区', '自旋锁可被中断处理程序持有，读写自旋锁不能', '自旋锁是独占锁，读写自旋锁允许多个读者同时访问'],  
        correctAnswer: 'D',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '自旋锁和读写自旋锁的主要区别是：自旋锁是独占锁（任何时刻只允许一个持有者），而读写自旋锁区分读操作和写操作，允许多个读者同时访问，但写者需要独占访问。当数据结构经常被读取但很少被修改时，读写自旋锁可以提高并发性。两种锁都适用于短临界区，都可在多处理器系统使用，也都可被中断处理程序持有（但需要适当的中断禁用）。'  
    },  
    {  
        text: '在多线程编程中，什么是"线程池"？',  
        options: ['一组等待被终止的线程', '一组共享相同优先级的线程', '预先创建的线程集合，用于执行提交的任务', '一组访问相同内存区域的线程'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '线程池是预先创建的一组线程，用于执行提交的任务。线程池的主要优势是避免了频繁创建和销毁线程的开销，通过重用已创建的线程提高了性能。此外，线程池还可以限制并发线程的最大数量，防止系统因线程过多而耗尽资源。线程池通常包含一个工作队列，线程从队列中获取任务执行；当任务完成时，线程不会终止，而是返回池中等待下一个任务。'  
    },  
    {  
        text: '在Linux的进程状态中，D状态和Z状态的主要区别是什么？',  
        options: ['D状态进程在等待CPU，Z状态进程正在运行', 'D状态进程正在等待I/O，Z状态进程已经终止但未被回收', 'D状态进程可以被信号终止，Z状态进程不能', 'D状态是正常的睡眠状态，Z状态是深度睡眠状态'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'D状态（不可中断睡眠）和Z状态（僵尸）的主要区别是：D状态进程正在等待某些系统资源（通常是I/O操作），不响应信号，不能被强制终止；Z状态进程已经终止执行，但其退出状态尚未被父进程通过wait()或waitpid()回收，仅在进程表中保留一个条目。D状态通常是暂时的，但如果出现硬件问题可能持续较长时间；Z状态进程不消耗系统资源（除了进程表条目），但如果父进程不正确处理子进程终止，系统可能累积大量僵尸进程。'  
    },  
    {  
        text: '在Linux的device文件中，主设备号和次设备号是如何分配的？',  
        options: ['主设备号由操作系统随机分配，次设备号由驱动程序指定', '主设备号标识设备类型，次设备号区分同类设备中的不同单元', '主设备号表示块设备，次设备号表示字符设备', '主设备号和次设备号都是按照设备接入顺序自动分配的'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '在Linux的device文件中，主设备号标识设备类型或对应的驱动程序，次设备号用于区分同类设备中的不同单元或实例。例如，硬盘驱动器可能使用相同的主设备号，但每个分区有不同的次设备号。主设备号在系统中应该是唯一的（对于一种设备类型），可以静态分配（在内核源代码中定义）或动态分配。驱动程序开发者通常使用register_chrdev()或register_blkdev()函数注册设备号，现代驱动程序开发通常使用设备模型框架自动处理设备号分配。'  
    },  
    {  
        text: '在Linux中，/proc文件系统的主要用途是什么？',  
        options: ['存储用户文件', '访问进程信息和系统状态', '管理设备驱动程序', '处理系统日志'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '/proc是一个虚拟文件系统，其主要用途是提供对进程信息和系统状态的访问。它不占用磁盘空间，而是由内核在内存中动态生成。在/proc中，每个进程都有一个以PID命名的目录，包含该进程的信息（如内存映射、状态、命令行等）；还有许多文件和目录提供系统信息（如/proc/cpuinfo、/proc/meminfo等）。/proc文件系统使得用户和应用程序可以通过简单的文件操作访问这些信息，也使系统管理工具（如ps、top）能够获取所需数据。'  
    },  
    {  
        text: '在Linux中，什么是"恐慌（Panic）"？',  
        options: ['用户级应用程序崩溃', '系统检测到硬件错误', '内核检测到无法恢复的错误状态并停止系统', '网络连接中断'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '在Linux中，"恐慌（Panic）"是指内核检测到无法恢复的错误状态，无法安全继续操作，因此停止系统。当发生恐慌时，内核通常会输出错误信息（如调用栈），然后根据配置可能重启系统或等待手动干预。常见的导致恐慌的原因包括严重的内存损坏、内核BUG、硬件故障等。与用户级应用程序崩溃不同，内核恐慌影响整个系统的稳定性，通常需要重启系统才能恢复。'  
    },  
    {  
        text: '在Linux中，select()系统调用的主要限制是什么？',  
        options: ['只能监视输入，不能监视输出', '文件描述符数量受FD_SETSIZE限制', '只能用于网络套接字，不能用于普通文件', '不支持超时设置'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'select()系统调用的主要限制是文件描述符数量受FD_SETSIZE限制（通常为1024）。此外，select()在每次调用时需要重新设置描述符集，并且需要在内核和用户空间之间复制这些集合，当监视大量描述符时效率较低。select()可以监视输入、输出和异常条件，适用于各种类型的文件描述符（包括套接字和普通文件，虽然对普通文件的行为可能不如预期），并且支持超时设置。较新的poll()和epoll()系统调用解决了一些select()的限制。'  
    },  
    {  
        text: '在Linux内核中，什么是jiffies？',  
        options: ['一种内存分配算法', '内核中当前时间的表示方式', '自系统启动以来的时钟滴答数', '一种进程调度策略'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'jiffies是Linux内核中的一个全局变量，表示自系统启动以来的时钟滴答（tick）数。每当系统时钟中断发生时，jiffies的值会增加。jiffies常用于内核中测量时间间隔和实现超时，例如在等待某个事件时检查是否超过指定的时间。jiffies的增加频率由HZ常量决定（通常为100-1000Hz，取决于内核配置），这意味着jiffies每秒增加HZ次。'  
    },  
    {  
        text: '在Linux中，用户态与内核态的区别主要在于？',  
        options: ['用户态程序由普通用户编写，内核态程序由系统管理员编写', '用户态使用高级语言，内核态使用汇编语言', '用户态具有较低的特权级别和受限的资源访问权限，内核态具有完全控制权', '用户态程序运行在真实硬件上，内核态程序运行在虚拟机中'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '用户态与内核态的主要区别在于特权级别和资源访问权限。内核态（也称为管理模式或系统模式）拥有最高特权级别，可以执行所有CPU指令、直接访问所有内存和硬件资源。用户态运行在较低的特权级别，只能执行非特权指令，对系统资源的访问受到限制，必须通过系统调用请求内核提供服务。这种区分是计算机系统安全和稳定性的基础，防止用户程序意外或恶意损坏系统。用户态和内核态之间的切换通常由系统调用、中断或异常触发。'  
    },  
    {  
        text: '在Linux中，下列哪个信号用于在父进程终止时通知子进程？',  
        options: ['SIGCHLD', 'SIGTERM', 'SIGHUP', 'SIGINT'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'SIGHUP（挂起信号）传统上用于表示控制终端关闭，但在现代Linux中，当父进程终止时，其子进程（如果是一个进程组的首进程）通常会收到SIGHUP信号。这使得守护进程可以优雅地处理其父进程（通常是终端会话）的终止。SIGCHLD则相反，是子进程终止时发送给父进程的信号；SIGTERM是请求进程终止的常规信号；SIGINT通常由用户通过Ctrl+C发送，请求中断进程。'  
    },  
    {  
        text: '在Linux线程编程中，什么是"mutex"？',  
        options: ['一种消息传递机制', '多线程执行的调度策略', '互斥锁，用于保护共享资源', '一种线程创建模式'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'mutex（互斥锁）是一种同步原语，用于保护多线程环境中的共享资源，确保在任何时刻只有一个线程可以访问该资源。当线程尝试获取已被其他线程持有的mutex时，它将被阻塞，直到持有线程释放mutex。在POSIX线程库中，通过pthread_mutex_t类型表示mutex，使用pthread_mutex_lock()和pthread_mutex_unlock()函数操作。mutex是处理线程间竞争条件的基本工具，确保临界区的互斥访问。'  
    },  
    {  
        text: '在多核处理器系统上，什么可能导致"伪共享（False Sharing）"问题？',  
        options: ['线程使用不同的锁保护相同的数据', '不同线程访问的数据位于同一缓存行', '线程误用其他线程的私有数据', '存储设备的IO竞争'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '伪共享（False Sharing）发生在不同线程访问的数据恰好位于同一缓存行（cache line）时。虽然这些变量在逻辑上是独立的，但由于它们位于同一缓存行，一个核心对其变量的修改会导致其他核心的缓存行失效，迫使它们重新从内存加载数据，即使它们实际上没有共享数据。这会显著影响性能，特别是在多线程并行计算中。解决方法包括变量填充（使相互独立的变量位于不同的缓存行）或重组数据结构。'  
    },  
    {  
        text: '在Linux中，共享库（动态链接库）与静态链接库相比的主要优势是什么？',  
        options: ['执行速度更快', '节省内存和磁盘空间', '不需要编译', '只能由超级用户使用'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '共享库（也称为动态链接库，在Linux中通常以.so结尾）相比静态链接库的主要优势是节省内存和磁盘空间。多个程序可以共享同一个库文件的代码，而不是每个程序都包含库代码的副本。此外，共享库还使得库更新更容易（只需替换库文件，而不需要重新编译所有使用该库的程序），并支持运行时动态加载（使用dlopen()等函数）。然而，共享库可能引入版本兼容性问题，且启动时间可能略长（由于动态链接的开销）。'  
    },  
    {  
        text: '在Linux文件系统中，什么是"硬连接（Hard Link）"？',  
        options: ['一个特殊的文件，指向另一个文件的路径', '一个指向同一个inode的目录项', '一个指向另一个分区的链接', '一个只能由root创建的特殊链接'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '硬连接是一个指向同一个inode的目录项。当创建硬连接时，本质上是创建了一个新的文件名，但它与原文件共享相同的inode号和数据块。硬连接与原文件完全等价，不区分"原始"和"链接"。硬连接的限制是不能跨文件系统创建，也不能链接到目录（在大多数文件系统上）。每个文件的inode记录了硬连接数量，只有当最后一个硬连接被删除时，文件的数据块才会被释放。'  
    },  
    {  
        text: '在Linux系统编程中，什么是"非阻塞I/O"？',  
        options: ['一种不需要权限的I/O操作', '一种不等待I/O完成就返回的操作模式', '一种加密的I/O操作，阻塞监视', '一种只能用于特殊设备的I/O方式'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '非阻塞I/O是一种不等待I/O操作完成就返回的操作模式。当设置了非阻塞标志（通常通过fcntl()函数设置O_NONBLOCK标志）后，I/O系统调用如read()在没有可用数据时不会阻塞进程，而是立即返回一个错误（通常是EAGAIN或EWOULDBLOCK）。这使得程序可以在等待I/O的同时执行其他任务，常用于实现高性能服务器。非阻塞I/O通常与select()、poll()或epoll()等多路I/O复用机制结合使用，以确定何时可以无阻塞地执行I/O操作。'  
    },  
    {  
        text: '在Linux中，什么是"信号量（Semaphore）"？',  
        options: ['一种进程间发送消息的机制', '一种限制对资源访问的计数器', '一种网络协议', '一种进程优先级调整机制'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '信号量是一种限制对资源访问的计数器，用于解决进程或线程间的同步问题。信号量维护一个计数值，通过两个原子操作控制：P操作（也称wait或down）减少计数值，如果结果小于0则阻塞；V操作（也称signal或up）增加计数值，可能唤醒等待的进程。Linux提供了两种信号量实现：POSIX信号量（sem_t类型，使用sem_wait()和sem_post()函数）和System V信号量（使用semget()、semop()函数）。信号量可以用于互斥访问（初始值为1）或资源计数（初始值大于1）。'  
    },  
    {  
        text: '在Linux系统中，什么是"孤儿进程（Orphan Process）"？',  
        options: ['CPU使用率过高的进程', '内存泄漏的进程', '父进程已终止但仍在运行的子进程', '无法被终止的僵尸进程'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '孤儿进程是指父进程已终止但子进程仍在运行的进程。当一个进程成为孤儿时，它会被init进程（PID 1）或类似的系统进程收养，成为其子进程。这确保了每个进程都有一个父进程，维持了进程层次结构。孤儿进程本身不是问题，是正常的系统行为。相比之下，僵尸进程是已终止但父进程未回收其资源的进程，如果大量存在可能导致问题。创建守护进程时，故意使进程成为孤儿是常见的技术，以便它可以在后台独立运行。'  
    },  
    {  
        text: '在Linux Shell编程中，"shebang"（#!）的作用是什么？',  
        options: ['注释行的开始', '声明脚本需要root权限', '指定解释器路径', '定义脚本的退出状态'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'shebang（#!）出现在脚本第一行开头，用于指定解释器的路径，告诉系统使用哪个程序执行该脚本。例如，"#!/bin/bash"指定使用bash解释器，"#!/usr/bin/python3"指定使用Python 3。当脚本被直接执行（而不是作为解释器的参数）时，系统会使用shebang指定的程序来解释执行该脚本。这使得用户可以像执行普通程序一样执行脚本，而不需要显式指定解释器。'  
    },  
    {  
        text: '在Linux系统中，如何防止buffer overflow攻击？',  
        options: ['只使用静态内存分配', '使用不可执行栈和地址空间随机化等技术', '禁用所有网络服务', '只允许root用户运行程序'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '防止buffer overflow攻击的主要方法包括使用不可执行栈（NX/DEP）和地址空间随机化（ASLR）等技术。不可执行栈防止攻击者注入并执行恶意代码；地址空间随机化使得预测内存地址变得困难。其他重要的防护措施包括：使用安全的编程实践（如边界检查、使用安全函数）、编译器保护（如栈保护、堆栈金丝雀）、及时应用安全补丁等。只使用静态内存分配、禁用网络服务或限制用户运行程序是不实际或不充分的解决方案。'  
    },  
    {  
        text: '在Linux文件权限中，粘滞位（sticky bit）设置在目录上的作用是什么？',  
        options: ['使目录内容对所有用户可读', '阻止非root用户访问目录', '防止用户删除其他用户在该目录中创建的文件', '使目录内的程序以root权限运行'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '粘滞位（sticky bit）设置在目录上时，防止用户删除或重命名其他用户在该目录中创建的文件，即使该用户对目录有写权限。只有文件所有者、目录所有者或root用户可以删除或重命名这些文件。这个特性常用于共享目录，如/tmp，确保用户只能修改自己的文件。粘滞位通过chmod命令设置，如`chmod +t directory`，在目录权限中显示为最后一个字符为"t"或"T"（如drwxrwxrwt）。'  
    },  
    {  
        text: '在Linux系统启动过程中，initramfs的作用是什么？',  
        options: ['初始化显示设备', '加载临时根文件系统，以便于访问真正的根文件系统', '检查磁盘错误', '配置网络接口'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'initramfs（初始RAM文件系统）的主要作用是在Linux启动过程中加载临时根文件系统到内存中，提供必要的驱动和工具，以便于访问真正的根文件系统。这解决了一个"鸡生蛋、蛋生鸡"的问题：内核需要驱动来访问根文件系统，但这些驱动可能存储在根文件系统上。initramfs包含必要的驱动模块、工具和脚本，使内核能够挂载实际的根文件系统并继续启动过程。它对于处理加密文件系统、LVM、RAID等高级存储配置尤为重要。'  
    },  
    {  
        text: '在Linux内核模块中，MODULE_LICENSE宏的作用是什么？',  
        options: ['检查用户是否有安装模块的许可', '声明模块的许可证类型', '限制模块的使用范围', '记录模块的版权信息'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'MODULE_LICENSE宏用于声明内核模块的许可证类型。这个信息被内核用来决定模块可以访问的内核功能范围 - 只有使用GPL兼容许可证的模块才能访问某些被标记为EXPORT_SYMBOL_GPL的内核符号。此外，这个信息也用于警告用户可能加载了专有模块。常见的许可证声明包括"GPL"、"GPL v2"、"Dual BSD/GPL"等。例如：MODULE_LICENSE("GPL");。这个宏是模块源代码中的声明性语句，不执行实际的许可证检查或执行。'  
    },  
    {  
        text: '在Linux I/O模型中，"异步I/O"与"非阻塞I/O"的主要区别是什么？',  
        options: ['异步I/O支持多个文件描述符，非阻塞I/O只支持一个', '异步I/O由内核实现，非阻塞I/O由用户实现', '异步I/O完全由内核处理并通知完成，非阻塞I/O需要应用程序轮询', '异步I/O只用于网络操作，非阻塞I/O用于文件操作'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '异步I/O与非阻塞I/O的主要区别在于I/O操作完成的处理方式。在异步I/O中，应用程序发起I/O请求后立即返回继续执行，整个I/O操作（包括等待数据和数据复制）由内核完成，然后通知应用程序（通常通过信号或回调）。而在非阻塞I/O中，虽然系统调用不会阻塞，但应用程序需要通过轮询（可能结合select/poll/epoll）来检查I/O操作是否可以无阻塞地进行。简言之，异步I/O提供了"发起并忘记"的模型，而非阻塞I/O仍需应用程序积极参与I/O完成的检测。'  
    },  
    {  
        text: '在Linux中，"coredump"文件的主要用途是什么？',  
        options: ['备份系统核心配置', '存储进程崩溃时的内存映像，用于调试', '记录系统性能数据', '存储内核日志'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'coredump文件的主要用途是存储进程异常终止（如段错误、非法指令等）时的内存映像，用于事后调试分析。这个文件包含了进程的地址空间内容、寄存器状态、线程信息等，使开发者能够确定崩溃原因，即使没有在调试器中运行程序。要生成coredump文件，需要适当配置系统（通过ulimit命令或/proc/sys/kernel/core_pattern）。使用gdb等调试工具可以分析coredump文件，查看崩溃时的调用栈、变量值等信息，这对于调试生产环境中的问题特别有价值。'  
    },  
    {  
        text: '在Linux中，以下哪项不是fork()系统调用的特点？',  
        options: ['子进程获得父进程内存页的副本', '子进程继承父进程的文件描述符', '子进程的进程ID与父进程相同', '子进程的资源使用统计信息被重置'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '子进程的进程ID(PID)与父进程不同，这是fork()的一个基本特点。每个进程在系统中必须有唯一的PID。其他选项都是fork()的正确特性：子进程确实获得父进程内存页的副本（通过写时复制机制优化）；子进程继承父进程的打开文件描述符（除非设置了close-on-exec标志）；子进程的资源使用统计信息（如CPU时间）被重置。此外，子进程还继承父进程的当前工作目录、根目录、umask值、信号处理设置等，但有些资源如挂起的信号和定时器不被继承。'  
    },  
    {  
        text: '在Linux系统中，/dev/null设备的主要用途是什么？',  
        options: ['存储临时文件', '生成随机数据', '丢弃所有写入的数据', '阻塞进程直到有数据可读'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '/dev/null是一个特殊的设备文件，它的主要用途是丢弃所有写入的数据。这个设备经常被称为"位桶"或"黑洞"，因为写入它的任何数据都会被简单地丢弃。读取/dev/null总是立即返回EOF（文件结束）。/dev/null的常见用途包括：抑制命令的输出（如`command > /dev/null`）、在shell脚本中丢弃不需要的输出，以及作为一个始终可用但不占用空间的"垃圾桶"。它是Linux系统中一个简单但非常有用的工具。'  
    },  
    {  
        text: '在Linux中，"竞争条件（Race Condition）"是指什么？',  
        options: ['两个进程竞争CPU资源', '程序执行速度过慢', '程序结果依赖于不可控的执行顺序', '内存泄漏导致的系统资源耗尽'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '竞争条件是指程序的结果依赖于不可控的执行顺序，通常出现在多线程或多进程环境中。当两个或多个线程/进程并发访问共享数据，且至少有一个在修改数据时，如果访问顺序会影响最终结果，就存在竞争条件。这种情况下，程序的行为变得不可预测，可能导致数据损坏、程序崩溃或安全漏洞。解决竞争条件通常需要使用同步机制，如互斥锁、信号量、原子操作等，确保关键操作的原子性、可见性和顺序性。'  
    },  
    {  
        text: '在Linux内核中，自旋锁（spinlock）与互斥锁（mutex）的主要区别是什么？',  
        options: ['自旋锁不会引起上下文切换，互斥锁会', '自旋锁只能在单处理器系统使用，互斥锁可在多处理器系统使用', '自旋锁保护用户空间数据，互斥锁保护内核空间数据', '自旋锁是用户态概念，互斥锁是内核态概念'],  
        correctAnswer: 'A',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '自旋锁与互斥锁的主要区别是：自旋锁在等待获取锁时会持续尝试（自旋），不会引起上下文切换或休眠，适合保护短临界区；而互斥锁在无法获取时会使线程休眠，释放CPU资源，在锁可用时再被唤醒，这涉及上下文切换。自旋锁和互斥锁都可以在多处理器系统中使用，都是内核提供的同步机制，可以保护内核或用户空间数据（通过合适的API）。在单处理器系统上，自旋锁通常会被简化为禁用抢占的操作，因为没有其他CPU可以并行执行。'  
    },  
    {  
        text: '在Linux中，什么是"用户空间文件系统（FUSE）"？',  
        options: ['一种只能由特权用户访问的文件系统', '一种允许在用户空间实现文件系统的机制', '一种专门存储用户数据的文件系统', '一种加密文件系统'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'FUSE（Filesystem in Userspace）是一种允许在用户空间实现文件系统的机制。传统上，文件系统代码运行在内核空间，需要内核编程知识并且调试困难。FUSE提供了一个内核模块，将文件系统操作从内核空间转发到用户空间程序，使开发者能够使用普通的编程语言和工具创建文件系统，而无需修改内核代码。FUSE使得实现特殊功能的文件系统变得更加容易，如网络文件系统（sshfs）、云存储文件系统、加密文件系统等。任何具有适当权限的用户都可以挂载和使用FUSE文件系统。'  
    },  
    {  
        text: '在Linux内核开发中，内核模块与直接编译进内核的代码相比有什么优势？',  
        options: ['更高的执行效率', '可以在不重启系统的情况下加载和卸载', '可以访问更多的内核功能', '不需要源代码就能开发'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '内核模块相比直接编译进内核的代码的主要优势是可以在不重启系统的情况下加载和卸载。这大大简化了开发和测试过程，使得功能可以动态添加或移除。其他优势包括：可以单独编译模块而不需要重新编译整个内核；系统可以根据需要加载模块，减少内存占用；便于分发专有驱动程序而不发布内核源代码。内核模块的执行效率与直接编译进内核的代码基本相当；两者可以访问相同的内核功能（除了一些导出符号的限制）；两者都需要源代码才能开发（除非使用二进制模块，如某些闭源驱动）。'  
    },  
    {  
        text: '在Linux系统调用中，mmap()的主要功能是什么？',  
        options: ['创建内存映射文件', '分配内存块', '修改内存保护属性', '复制内存区域'],  
        correctAnswer: 'A',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'mmap()系统调用的主要功能是创建内存映射文件，即将文件或设备映射到进程的地址空间。这样，进程可以通过访问内存区域来直接读写文件内容，而不需要使用read()或write()系统调用。mmap()的用途广泛：创建文件映射（用于高效I/O）；创建匿名映射（用于内存分配，类似malloc）；创建共享映射（用于进程间通信）；创建私有映射（用于写时复制）等。例如，许多内存分配器在底层使用mmap()，一些数据库使用mmap()提高性能，共享库也通过mmap()加载到进程地址空间。'  
    },  
{  
        text: '在Linux C编程中，以下哪个函数可以检查和处理僵尸进程？',  
        options: ['kill()', 'wait()', 'fork()', 'exit()'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
		        explanation: 'wait()函数用于检查和处理僵尸进程。当子进程终止时，它的资源大部分被释放，但进程表中的条目保留，成为"僵尸进程"，直到父进程调用wait()或waitpid()读取子进程的退出状态并完全释放其资源。wait()函数使父进程等待任何子进程终止并获取其退出状态；waitpid()允许等待特定的子进程。如果父进程没有调用这些函数，僵尸进程会一直存在，可能导致系统资源问题。在编写多进程程序时，正确处理子进程终止是良好实践的重要部分。'  
    },  
    {  
        text: '在Linux信号编程中，signal()函数的限制是什么？',  
        options: ['不能处理实时信号', '在不同UNIX系统上行为不一致', '不能在多线程程序中使用', '只能由root用户调用'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'signal()函数的主要限制是在不同UNIX系统上行为不一致。signal()是一个较老的接口，其语义在各种UNIX实现中有所不同，特别是关于信号处理程序是否在处理信号后被重置、是否自动阻塞同类信号等方面。这种不一致性使得使用signal()编写的程序在不同系统上可能表现不同。因此，现代程序应该使用更可靠和一致的sigaction()函数，它提供了更精细的控制和可预测的行为。虽然signal()不能处理实时信号(>SIGRTMIN)，在多线程程序中使用时有限制，但这些不是其主要问题。'  
    },  
    {  
        text: '在Linux内核中，slab分配器比通用的kmalloc/kfree有哪些优势？',  
        options: ['可以分配更大的内存块', '减少内存碎片和分配开销', '可以在中断上下文中使用', '支持用户空间内存分配'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'slab分配器比通用的kmalloc/kfree的主要优势是减少内存碎片和分配开销。slab针对特定大小的对象创建缓存，重用释放的对象而不是完全释放内存，这减少了内存碎片。此外，它还预初始化对象，降低了重复创建类似对象的开销。kmalloc实际上是基于slab实现的，对于常见大小提供了通用接口。两者都可以在中断上下文中使用，都只用于内核空间分配，且slab通常不用于分配非常大的内存块（大块内存更适合使用page allocator）。'  
    },  
    {  
        text: '在Linux中，以下哪个系统调用可以修改进程的调度策略和优先级？',  
        options: ['sched_yield()', 'sched_setscheduler()', 'nice()', 'prlimit()'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: 'sched_setscheduler()系统调用可以修改进程的调度策略和优先级。它允许设置进程的调度策略（如SCHED_OTHER、SCHED_FIFO、SCHED_RR）以及相应的优先级参数。只有特权进程（通常是root）可以提高优先级或设置实时调度策略。nice()只能调整进程的nice值（影响SCHED_OTHER策略下的优先级）；sched_yield()让进程自愿放弃CPU，但不改变其调度属性；prlimit()用于获取/设置资源限制，不直接涉及调度。'  
    },  
    {  
        text: '在Linux中，以下哪个文件包含内核支持的文件系统列表？',  
        options: ['/proc/mounts', '/etc/fstab', '/proc/filesystems', '/sys/fs/'],  
        correctAnswer: 'C',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '/proc/filesystems文件包含内核支持的文件系统列表，包括直接编译进内核的和通过模块加载的文件系统。文件中的"nodev"标记表示该文件系统不需要关联块设备（如proc、sysfs等）。相比之下，/proc/mounts显示当前挂载的文件系统；/etc/fstab是系统启动时要挂载的文件系统配置；/sys/fs/是sysfs中与文件系统相关的目录，包含各种文件系统的信息和控制接口。'  
    },  
    {  
        text: '在Linux多线程编程中，条件变量（condition variable）必须与什么一起使用？',  
        options: ['信号量', '互斥锁', '自旋锁', '原子操作'],  
        correctAnswer: 'B',  
        userAnswer: '',  
        checked: false,  
        counted: false,  
        explanation: '条件变量必须与互斥锁一起使用。条件变量本身不保护共享数据，它们只是用于线程间的通知机制，当某个条件满足时发出信号。互斥锁用于保护与条件相关的共享数据，并确保在检查条件和等待之间的原子性。典型使用模式是：线程获取互斥锁，检查条件，如果条件不满足则调用pthread_cond_wait()（自动释放互斥锁并阻塞），当被唤醒时自动重新获取互斥锁并再次检查条件。这种互斥锁和条件变量的配合使用是正确实现线程同步的关键。'  
    }  
 
	</script>
	<script>  
        function quizApp() {  
            return {  
                // 题目数据
                questions: [],
                
                answeredCount: 0,  
                correctCount: 0,  
                incorrectCount: 0,  
                accuracyRate: 0,  

                init() {
                    // 从script标签获取问题数据
                    const questionsScript = document.getElementById('questionData');
                    if (questionsScript) {
                        try {
                            const questionsText = questionsScript.textContent;
                            // 将文本内容转换为有效的JSON格式
                            const jsonText = '[' + questionsText + ']';
                            
                            // 解析JSON并初始化问题
                            this.questions = eval(jsonText);
                        } catch (e) {
                            console.error("Error parsing questions: ", e);
                            this.questions = [];
                        }
                    }
                },
                
                checkAnswer(index) {  
                    const question = this.questions[index];  
                    if (question.userAnswer) {  
                        question.checked = true;  
                        
                        // 只有第一次检查时才计入总数  
                        if (!question.counted) {  
                            this.answeredCount++;  
                            question.counted = true;  
                            
                            if (question.userAnswer === question.correctAnswer) {  
                                this.correctCount++;  
                            } else {  
                                this.incorrectCount++;  
                            }  
                        }  
                        
                        this.calculateAccuracy();  
                    }  
                },  
                
                calculateAccuracy() {  
                    if (this.answeredCount > 0) {  
                        this.accuracyRate = Math.round((this.correctCount / this.answeredCount) * 100);  
                    }  
                },  
                
                scrollToQuestion(questionNum) {  
                    const element = document.getElementById('question-' + questionNum);  
                    if (element) {  
                        element.scrollIntoView({ behavior: 'smooth' });  
                    }  
                },  
                
                getJumpButtonClass(questionNum) {  
                    // 检查该区域内的题目是否已回答  
                    let allAnswered = true;  
                    let anyAnswered = false;  
                    let allCorrect = true;  
                    
                    for (let i = questionNum; i < questionNum + 5 && i <= this.questions.length; i++) {  
                        if (this.questions[i-1] && this.questions[i-1].counted) {  
                            anyAnswered = true;  
                            if (this.questions[i-1].userAnswer !== this.questions[i-1].correctAnswer) {  
                                allCorrect = false;  
                            }  
                        } else {  
                            allAnswered = false;  
                        }  
                    }  
                    
                    if (allAnswered && allCorrect) return 'bg-green-500 text-white';  
                    if (allAnswered) return 'bg-green-100 text-green-800';  
                    if (anyAnswered) return 'bg-yellow-100 text-yellow-800';  
                    return 'bg-gray-100 text-gray-800';  
                },  
                
                printResults() {  
                    // 首先强制检查所有已回答但未检查的题目  
                    this.questions.forEach((question, index) => {  
                        if (question.userAnswer && !question.checked) {  
                            this.checkAnswer(index);  
                        }  
                    });  
                    
                    // 然后打印页面  
                    window.print();  
                }  
            }  
        }  
    </script>  
</body>  
</html>
